import * as l from "react";
import { clamp as Y } from "./index234.js";
import { composeEventHandlers as _ } from "./index97.js";
import { useComposedRefs as C } from "./index98.js";
import { createContextScope as ce } from "./index99.js";
import { useControllableState as le } from "./index109.js";
import { useDirection as de } from "./index233.js";
import { usePrevious as ue } from "./index235.js";
import { useSize as fe } from "./index164.js";
import { Primitive as V } from "./index107.js";
import { createCollection as me } from "./index231.js";
import { j as S } from "./index7.js";
var $ = ["PageUp", "PageDown"], X = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], G = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, M = "Slider", [H, pe, Se] = me(M), [W] = ce(M, [
  Se
]), [he, j] = W(M), q = l.forwardRef(
  (e, t) => {
    const {
      name: o,
      min: n = 0,
      max: s = 100,
      step: c = 1,
      orientation: r = "horizontal",
      disabled: a = !1,
      minStepsBetweenThumbs: u = 0,
      defaultValue: w = [n],
      value: h,
      onValueChange: i = () => {
      },
      onValueCommit: d = () => {
      },
      inverted: v = !1,
      form: R,
      ...g
    } = e, m = l.useRef(/* @__PURE__ */ new Set()), f = l.useRef(0), x = r === "horizontal" ? ge : ve, [p = [], K] = le({
      prop: h,
      defaultProp: w,
      onChange: (b) => {
        [...m.current][f.current]?.focus(), i(b);
      }
    }), B = l.useRef(p);
    function T(b) {
      const y = ye(p, b);
      I(b, y);
    }
    function se(b) {
      I(b, f.current);
    }
    function ae() {
      const b = B.current[f.current];
      p[f.current] !== b && d(p);
    }
    function I(b, y, { commit: k } = { commit: !1 }) {
      const U = _e(c), z = Ce(Math.round((b - n) / c) * c + n, U), A = Y(z, [n, s]);
      K((E = []) => {
        const P = be(E, A, y);
        if (Ee(P, u * c)) {
          f.current = P.indexOf(A);
          const F = String(P) !== String(E);
          return F && k && d(P), F ? P : E;
        } else
          return E;
      });
    }
    return /* @__PURE__ */ S.jsx(
      he,
      {
        scope: e.__scopeSlider,
        name: o,
        disabled: a,
        min: n,
        max: s,
        valueIndexToChangeRef: f,
        thumbs: m.current,
        values: p,
        orientation: r,
        form: R,
        children: /* @__PURE__ */ S.jsx(H.Provider, { scope: e.__scopeSlider, children: /* @__PURE__ */ S.jsx(H.Slot, { scope: e.__scopeSlider, children: /* @__PURE__ */ S.jsx(
          x,
          {
            "aria-disabled": a,
            "data-disabled": a ? "" : void 0,
            ...g,
            ref: t,
            onPointerDown: _(g.onPointerDown, () => {
              a || (B.current = p);
            }),
            min: n,
            max: s,
            inverted: v,
            onSlideStart: a ? void 0 : T,
            onSlideMove: a ? void 0 : se,
            onSlideEnd: a ? void 0 : ae,
            onHomeKeyDown: () => !a && I(n, 0, { commit: !0 }),
            onEndKeyDown: () => !a && I(s, p.length - 1, { commit: !0 }),
            onStepKeyDown: ({ event: b, direction: y }) => {
              if (!a) {
                const z = $.includes(b.key) || b.shiftKey && X.includes(b.key) ? 10 : 1, A = f.current, E = p[A], P = c * z * y;
                I(E + P, A, { commit: !0 });
              }
            }
          }
        ) }) })
      }
    );
  }
);
q.displayName = M;
var [J, Q] = W(M, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), ge = l.forwardRef(
  (e, t) => {
    const {
      min: o,
      max: n,
      dir: s,
      inverted: c,
      onSlideStart: r,
      onSlideMove: a,
      onSlideEnd: u,
      onStepKeyDown: w,
      ...h
    } = e, [i, d] = l.useState(null), v = C(t, (x) => d(x)), R = l.useRef(void 0), g = de(s), m = g === "ltr", f = m && !c || !m && c;
    function D(x) {
      const p = R.current || i.getBoundingClientRect(), K = [0, p.width], T = O(K, f ? [o, n] : [n, o]);
      return R.current = p, T(x - p.left);
    }
    return /* @__PURE__ */ S.jsx(
      J,
      {
        scope: e.__scopeSlider,
        startEdge: f ? "left" : "right",
        endEdge: f ? "right" : "left",
        direction: f ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ S.jsx(
          Z,
          {
            dir: g,
            "data-orientation": "horizontal",
            ...h,
            ref: v,
            style: {
              ...h.style,
              "--radix-slider-thumb-transform": "translateX(-50%)"
            },
            onSlideStart: (x) => {
              const p = D(x.clientX);
              r?.(p);
            },
            onSlideMove: (x) => {
              const p = D(x.clientX);
              a?.(p);
            },
            onSlideEnd: () => {
              R.current = void 0, u?.();
            },
            onStepKeyDown: (x) => {
              const K = G[f ? "from-left" : "from-right"].includes(x.key);
              w?.({ event: x, direction: K ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), ve = l.forwardRef(
  (e, t) => {
    const {
      min: o,
      max: n,
      inverted: s,
      onSlideStart: c,
      onSlideMove: r,
      onSlideEnd: a,
      onStepKeyDown: u,
      ...w
    } = e, h = l.useRef(null), i = C(t, h), d = l.useRef(void 0), v = !s;
    function R(g) {
      const m = d.current || h.current.getBoundingClientRect(), f = [0, m.height], x = O(f, v ? [n, o] : [o, n]);
      return d.current = m, x(g - m.top);
    }
    return /* @__PURE__ */ S.jsx(
      J,
      {
        scope: e.__scopeSlider,
        startEdge: v ? "bottom" : "top",
        endEdge: v ? "top" : "bottom",
        size: "height",
        direction: v ? 1 : -1,
        children: /* @__PURE__ */ S.jsx(
          Z,
          {
            "data-orientation": "vertical",
            ...w,
            ref: i,
            style: {
              ...w.style,
              "--radix-slider-thumb-transform": "translateY(50%)"
            },
            onSlideStart: (g) => {
              const m = R(g.clientY);
              c?.(m);
            },
            onSlideMove: (g) => {
              const m = R(g.clientY);
              r?.(m);
            },
            onSlideEnd: () => {
              d.current = void 0, a?.();
            },
            onStepKeyDown: (g) => {
              const f = G[v ? "from-bottom" : "from-top"].includes(g.key);
              u?.({ event: g, direction: f ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), Z = l.forwardRef(
  (e, t) => {
    const {
      __scopeSlider: o,
      onSlideStart: n,
      onSlideMove: s,
      onSlideEnd: c,
      onHomeKeyDown: r,
      onEndKeyDown: a,
      onStepKeyDown: u,
      ...w
    } = e, h = j(M, o);
    return /* @__PURE__ */ S.jsx(
      V.span,
      {
        ...w,
        ref: t,
        onKeyDown: _(e.onKeyDown, (i) => {
          i.key === "Home" ? (r(i), i.preventDefault()) : i.key === "End" ? (a(i), i.preventDefault()) : $.concat(X).includes(i.key) && (u(i), i.preventDefault());
        }),
        onPointerDown: _(e.onPointerDown, (i) => {
          const d = i.target;
          d.setPointerCapture(i.pointerId), i.preventDefault(), h.thumbs.has(d) ? d.focus() : n(i);
        }),
        onPointerMove: _(e.onPointerMove, (i) => {
          i.target.hasPointerCapture(i.pointerId) && s(i);
        }),
        onPointerUp: _(e.onPointerUp, (i) => {
          const d = i.target;
          d.hasPointerCapture(i.pointerId) && (d.releasePointerCapture(i.pointerId), c(i));
        })
      }
    );
  }
), ee = "SliderTrack", te = l.forwardRef(
  (e, t) => {
    const { __scopeSlider: o, ...n } = e, s = j(ee, o);
    return /* @__PURE__ */ S.jsx(
      V.span,
      {
        "data-disabled": s.disabled ? "" : void 0,
        "data-orientation": s.orientation,
        ...n,
        ref: t
      }
    );
  }
);
te.displayName = ee;
var N = "SliderRange", ne = l.forwardRef(
  (e, t) => {
    const { __scopeSlider: o, ...n } = e, s = j(N, o), c = Q(N, o), r = l.useRef(null), a = C(t, r), u = s.values.length, w = s.values.map(
      (d) => ie(d, s.min, s.max)
    ), h = u > 1 ? Math.min(...w) : 0, i = 100 - Math.max(...w);
    return /* @__PURE__ */ S.jsx(
      V.span,
      {
        "data-orientation": s.orientation,
        "data-disabled": s.disabled ? "" : void 0,
        ...n,
        ref: a,
        style: {
          ...e.style,
          [c.startEdge]: h + "%",
          [c.endEdge]: i + "%"
        }
      }
    );
  }
);
ne.displayName = N;
var L = "SliderThumb", oe = l.forwardRef(
  (e, t) => {
    const o = pe(e.__scopeSlider), [n, s] = l.useState(null), c = C(t, (a) => s(a)), r = l.useMemo(
      () => n ? o().findIndex((a) => a.ref.current === n) : -1,
      [o, n]
    );
    return /* @__PURE__ */ S.jsx(we, { ...e, ref: c, index: r });
  }
), we = l.forwardRef(
  (e, t) => {
    const { __scopeSlider: o, index: n, name: s, ...c } = e, r = j(L, o), a = Q(L, o), [u, w] = l.useState(null), h = C(t, (D) => w(D)), i = u ? r.form || !!u.closest("form") : !0, d = fe(u), v = r.values[n], R = v === void 0 ? 0 : ie(v, r.min, r.max), g = Re(n, r.values.length), m = d?.[a.size], f = m ? Pe(m, R, a.direction) : 0;
    return l.useEffect(() => {
      if (u)
        return r.thumbs.add(u), () => {
          r.thumbs.delete(u);
        };
    }, [u, r.thumbs]), /* @__PURE__ */ S.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [a.startEdge]: `calc(${R}% + ${f}px)`
        },
        children: [
          /* @__PURE__ */ S.jsx(H.ItemSlot, { scope: e.__scopeSlider, children: /* @__PURE__ */ S.jsx(
            V.span,
            {
              role: "slider",
              "aria-label": e["aria-label"] || g,
              "aria-valuemin": r.min,
              "aria-valuenow": v,
              "aria-valuemax": r.max,
              "aria-orientation": r.orientation,
              "data-orientation": r.orientation,
              "data-disabled": r.disabled ? "" : void 0,
              tabIndex: r.disabled ? void 0 : 0,
              ...c,
              ref: h,
              style: v === void 0 ? { display: "none" } : e.style,
              onFocus: _(e.onFocus, () => {
                r.valueIndexToChangeRef.current = n;
              })
            }
          ) }),
          i && /* @__PURE__ */ S.jsx(
            re,
            {
              name: s ?? (r.name ? r.name + (r.values.length > 1 ? "[]" : "") : void 0),
              form: r.form,
              value: v
            },
            n
          )
        ]
      }
    );
  }
);
oe.displayName = L;
var xe = "RadioBubbleInput", re = l.forwardRef(
  ({ __scopeSlider: e, value: t, ...o }, n) => {
    const s = l.useRef(null), c = C(s, n), r = ue(t);
    return l.useEffect(() => {
      const a = s.current;
      if (!a) return;
      const u = window.HTMLInputElement.prototype, h = Object.getOwnPropertyDescriptor(u, "value").set;
      if (r !== t && h) {
        const i = new Event("input", { bubbles: !0 });
        h.call(a, t), a.dispatchEvent(i);
      }
    }, [r, t]), /* @__PURE__ */ S.jsx(
      V.input,
      {
        style: { display: "none" },
        ...o,
        ref: c,
        defaultValue: t
      }
    );
  }
);
re.displayName = xe;
function be(e = [], t, o) {
  const n = [...e];
  return n[o] = t, n.sort((s, c) => s - c);
}
function ie(e, t, o) {
  const c = 100 / (o - t) * (e - t);
  return Y(c, [0, 100]);
}
function Re(e, t) {
  return t > 2 ? `Value ${e + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][e] : void 0;
}
function ye(e, t) {
  if (e.length === 1) return 0;
  const o = e.map((s) => Math.abs(s - t)), n = Math.min(...o);
  return o.indexOf(n);
}
function Pe(e, t, o) {
  const n = e / 2, c = O([0, 50], [0, n]);
  return (n - c(t) * o) * o;
}
function De(e) {
  return e.slice(0, -1).map((t, o) => e[o + 1] - t);
}
function Ee(e, t) {
  if (t > 0) {
    const o = De(e);
    return Math.min(...o) >= t;
  }
  return !0;
}
function O(e, t) {
  return (o) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const n = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + n * (o - e[0]);
  };
}
function _e(e) {
  return (String(e).split(".")[1] || "").length;
}
function Ce(e, t) {
  const o = Math.pow(10, t);
  return Math.round(e * o) / o;
}
var Ne = q, Le = te, Oe = ne, Ue = oe;
export {
  Oe as Range,
  Ne as Root,
  q as Slider,
  ne as SliderRange,
  oe as SliderThumb,
  te as SliderTrack,
  Ue as Thumb,
  Le as Track
};
