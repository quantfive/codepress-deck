import { getNativeImplementation as s, clearCachedImplementation as c } from "./index128.js";
import { createTransport as f } from "./index129.js";
import { rejectedSyncPromise as m } from "./index130.js";
function p(t, i = s("fetch")) {
  let r = 0, n = 0;
  function d(o) {
    const a = o.body.length;
    r += a, n++;
    const h = {
      body: o.body,
      method: "POST",
      referrerPolicy: "strict-origin",
      headers: t.headers,
      // Outgoing requests are usually cancelled when navigating to a different page, causing a "TypeError: Failed to
      // fetch" error and sending a "network_error" client-outcome - in Chrome, the request status shows "(cancelled)".
      // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're
      // frequently sending events right before the user is switching pages (eg. when finishing navigation transactions).
      // Gotchas:
      // - `keepalive` isn't supported by Firefox
      // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):
      //   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.
      //   We will therefore only activate the flag when we're below that limit.
      // There is also a limit of requests that can be open at the same time, so we also limit this to 15
      // See https://github.com/getsentry/sentry-javascript/pull/7553 for details
      keepalive: r <= 6e4 && n < 15,
      ...t.fetchOptions
    };
    if (!i)
      return c("fetch"), m("No fetch implementation available");
    try {
      return i(t.url, h).then((e) => (r -= a, n--, {
        statusCode: e.status,
        headers: {
          "x-sentry-rate-limits": e.headers.get("X-Sentry-Rate-Limits"),
          "retry-after": e.headers.get("Retry-After")
        }
      }));
    } catch (e) {
      return c("fetch"), r -= a, n--, m(e);
    }
  }
  return f(t, d);
}
export {
  p as makeFetchTransport
};
