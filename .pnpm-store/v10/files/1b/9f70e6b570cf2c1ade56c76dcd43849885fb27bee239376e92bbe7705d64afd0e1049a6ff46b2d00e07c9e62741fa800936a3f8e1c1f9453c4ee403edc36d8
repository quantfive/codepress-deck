import { API_BASE_URL, BASE_LOCAL_CODEPRESS_DEPRECATED, IS_DEVELOPMENT, } from "@/lib/env";
import Sentry from "@/sentry";
import logger from "./lib/logger.js";
import { getBrowserAPI } from "./lib/utils.js";
import { getProvidedToken } from "./lib/authTokenProvider.js";
// Storage key for auth token
export const TOKEN_STORAGE_KEY = "github_oauth_token";
/**
 * Generate a complete API URL from a path
 */
export function generateApiUrl(path) {
    // Remove leading slash if present
    const cleanPath = path.startsWith("/") ? path.slice(1) : path;
    return IS_DEVELOPMENT
        ? `${BASE_LOCAL_CODEPRESS_DEPRECATED}/${cleanPath}`
        : `${API_BASE_URL}/${cleanPath}`;
}
export function generateDirectApiUrl(path) {
    const cleanPath = path.startsWith("/") ? path.slice(1) : path;
    return `${API_BASE_URL}/${cleanPath}`;
}
/**
 * Get the current authorization token from background script
 */
export async function getAuthToken() {
    try {
        // Prefer provided token (from host app) when available
        const provided = await getProvidedToken();
        if (provided)
            return provided;
        const browserAPI = getBrowserAPI();
        if (browserAPI && browserAPI.storage) {
            const data = await browserAPI.storage.local.get("codepress.auth");
            const tokenData = data["codepress.auth"];
            if (!tokenData) {
                return null;
            }
            const { access_token, exp } = tokenData;
            if (!access_token) {
                return null;
            }
            // Check if token is expired
            if (Date.now() >= exp) {
                logger.info("Token expired, clearing from storage");
                await browserAPI.storage.local.remove([
                    "codepress.auth",
                    "github_user_data",
                ]);
                return null;
            }
            return access_token;
        }
        return null;
    }
    catch (error) {
        logger.error("Error getting auth token:", error);
        Sentry.captureException(error);
        return null;
    }
}
/**
 * Build request headers including authorization if token is available
 */
export async function buildHeaders(options = {}) {
    const { includeAuth = true, contentType = "application/json", additionalHeaders = {}, token, } = options;
    const headers = {};
    // Add content type if specified
    if (contentType) {
        headers["Content-Type"] = contentType;
    }
    // Add authorization if requested
    if (includeAuth) {
        const authToken = token || (await getAuthToken());
        if (authToken) {
            headers["Authorization"] = `Bearer ${authToken}`;
        }
    }
    // Add any additional headers
    return { ...headers, ...additionalHeaders };
}
/**
 * Create a config object for GET requests
 */
export async function GET_CONFIG(options = {}) {
    return {
        method: "GET",
        headers: await buildHeaders(options),
    };
}
/**
 * Convert camelCase keys to snake_case in an object
 */
function convertToSnakeCase(obj) {
    if (Array.isArray(obj)) {
        return obj.map((item) => convertToSnakeCase(item));
    }
    if (obj !== null && typeof obj === "object") {
        return Object.keys(obj).reduce((acc, key) => {
            const snakeKey = key.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
            acc[snakeKey] = convertToSnakeCase(obj[key]);
            return acc;
        }, {});
    }
    return obj;
}
/**
 * Create a config object for POST requests
 */
export async function POST_CONFIG(options = {}) {
    const { data, ...restOptions } = options;
    return {
        method: "POST",
        ...(data && { body: JSON.stringify(convertToSnakeCase(data)) }),
        headers: await buildHeaders(restOptions),
    };
}
/**
 * Create a config object for PUT requests
 */
export async function PUT_CONFIG(options = {}) {
    const { data, ...restOptions } = options;
    return {
        method: "PUT",
        ...(data && { body: JSON.stringify(convertToSnakeCase(data)) }),
        headers: await buildHeaders(restOptions),
    };
}
/**
 * Create a config object for PATCH requests
 */
export async function PATCH_CONFIG(options = {}) {
    const { data, ...restOptions } = options;
    return {
        method: "PATCH",
        ...(data && { body: JSON.stringify(convertToSnakeCase(data)) }),
        headers: await buildHeaders(restOptions),
    };
}
/**
 * Create a config object for DELETE requests
 */
export async function DELETE_CONFIG(options = {}) {
    return {
        method: "DELETE",
        headers: await buildHeaders(options),
    };
}
// Small helper to build a Response-like object from background results
function makeResponseLike(payload) {
    if (!payload) {
        throw new Error("Background fetch returned no response (check onMessage handler)");
    }
    const headers = new Headers(payload.headers || {});
    return {
        ok: payload.ok,
        status: payload.status,
        statusText: payload.statusText,
        headers,
        async json() {
            return JSON.parse(payload.bodyText || "null");
        },
        async text() {
            return payload.bodyText ?? "";
        },
    };
}
/**
 * Check if a request should use direct fetch (for streaming) instead of background proxy
 */
function isBackgroundServiceWorker() {
    if (typeof globalThis === "undefined")
        return false;
    const maybeSW = globalThis;
    return (typeof maybeSW.registration !== "undefined" &&
        typeof maybeSW.clients !== "undefined");
}
function shouldUseDirectFetch(config) {
    // Use direct fetch for streaming requests (SSE)
    return (config?.headers &&
        config.headers?.["Accept"] ===
            "text/event-stream");
}
/**
 * Direct fetch for streaming requests that bypass the background script
 * Used when background proxy doesn't support streaming
 */
async function directApiFetch(url, config) {
    try {
        // Add auth token directly to headers
        const authToken = await getAuthToken();
        const headers = { ...config?.headers };
        if (authToken) {
            headers["Authorization"] = `Bearer ${authToken}`;
        }
        const response = await fetch(url, {
            ...config,
            headers,
        });
        // Handle token refresh header if present
        const newToken = response.headers.get("X-New-Token");
        if (newToken) {
            await updateStoredToken(newToken);
            logger.info("🔄 Extension JWT refreshed (direct fetch)");
        }
        return response;
    }
    catch (error) {
        logger.error("Direct API fetch error:", error);
        Sentry.captureException(error);
        throw error;
    }
}
/**
 * Wrapper for fetch API that handles common errors and response parsing
 * Also handles automatic JWT token refresh
 * Automatically uses direct fetch for streaming requests
 */
export async function apiFetch(url, config) {
    // Use direct fetch for streaming requests to bypass background script limitations
    if (shouldUseDirectFetch(config)) {
        logger.info("Using direct fetch for streaming request:", url);
        return directApiFetch(url, config);
    }
    // Prefer background script proxy in extension; fall back to direct fetch elsewhere
    try {
        const browserAPI = getBrowserAPI();
        if (!browserAPI || isBackgroundServiceWorker()) {
            // Not running in extension context; use direct fetch with auth header
            return directApiFetch(url, config);
        }
        let result;
        try {
            result = await browserAPI.runtime.sendMessage({
                type: "API_FETCH",
                url,
                config: {
                    method: config?.method,
                    headers: config?.headers,
                    body: config?.body ?? null,
                },
            });
        }
        catch (messagingError) {
            const message = messagingError?.message ?? "";
            if (typeof message === "string" &&
                (message.includes("Could not establish connection") ||
                    message.includes("Receiving end does not exist"))) {
                logger.debug("Background messaging unavailable, falling back to direct fetch", message);
                return directApiFetch(url, config);
            }
            throw messagingError;
        }
        if (!result) {
            logger.warn("Background message returned no payload, falling back to direct fetch", url);
            return directApiFetch(url, config);
        }
        if (result?.error) {
            throw new Error(result.error);
        }
        const resp = makeResponseLike(result);
        // Handle token refresh header if present
        const newToken = resp.headers.get("X-New-Token");
        if (newToken) {
            await updateStoredToken(newToken);
            logger.info("🔄 Extension JWT refreshed");
        }
        // Keep original behavior: do not throw here; callers read resp.ok
        return resp;
    }
    catch (error) {
        logger.error("API fetch error:", error);
        Sentry.captureException(error);
        throw error;
    }
}
/**
 * Update stored token with new JWT from server
 */
async function updateStoredToken(newToken) {
    const browserAPI = getBrowserAPI();
    if (browserAPI?.storage) {
        try {
            // Decode to get new expiry
            const { exp } = JSON.parse(atob(newToken.split(".")[1]));
            await browserAPI.storage.local.set({
                "codepress.auth": {
                    access_token: newToken,
                    exp: exp * 1000, // Convert to milliseconds
                },
            });
        }
        catch (error) {
            logger.error("Failed to update stored token:", error);
            Sentry.captureException(error);
        }
    }
}
// Note: GitHub-specific API functions are moved to /lib/github/fetch.ts
/**
 * Logout functionality for browser extension
 */
export async function logout() {
    const token = await getAuthToken();
    if (!token) {
        // Already logged out
        return;
    }
    try {
        const response = await fetch(`${API_BASE_URL}/auth/logout`, {
            method: "POST",
            headers: await buildHeaders({ token }),
        });
        // Always clear extension storage, even if server request fails
        const browserAPI = getBrowserAPI();
        if (browserAPI?.storage) {
            await browserAPI.storage.local.remove([
                "codepress.auth",
                "github_user_data",
            ]);
        }
        if (response.ok) {
            logger.info("✅ Extension successfully logged out");
        }
        else {
            console.warn("⚠️ Extension logout request failed, but local storage cleared");
        }
    }
    catch (error) {
        logger.error("❌ Extension logout error:", error);
        Sentry.captureException(error);
        // Still clear local storage
        const browserAPI = getBrowserAPI();
        if (browserAPI?.storage) {
            await browserAPI.storage.local.remove([
                "codepress.auth",
                "github_user_data",
            ]);
        }
    }
}
/**
 * Logout from all devices
 */
export async function logoutAll() {
    const token = await getAuthToken();
    if (!token) {
        return;
    }
    try {
        const response = await fetch(`${API_BASE_URL}/auth/logout-all`, {
            method: "POST",
            headers: await buildHeaders({ token }),
        });
        // Always clear extension storage
        const browserAPI = getBrowserAPI();
        if (browserAPI?.storage) {
            await browserAPI.storage.local.remove([
                "codepress.auth",
                "github_user_data",
            ]);
        }
        if (response.ok) {
            logger.info("✅ Extension successfully logged out from all devices");
        }
        else {
            console.warn("⚠️ Extension logout all devices request failed, but local storage cleared");
        }
    }
    catch (error) {
        logger.error("❌ Extension logout all devices error:", error);
        Sentry.captureException(error);
        const browserAPI = getBrowserAPI();
        if (browserAPI?.storage) {
            await browserAPI.storage.local.remove([
                "codepress.auth",
                "github_user_data",
            ]);
        }
    }
}
/**
 * Add non-GitHub API methods here, for example:
 *
 * export async function fetchUserPreferences() {...}
 * export async function updateAppSettings(settings: any) {...}
 * etc.
 */
