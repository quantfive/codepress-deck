import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import React from "react";
import ReactDOM from "react-dom/client";
import { Toaster } from "sonner";
import Editor from "../components/Editor.js";
import { PortalProvider } from "../context/PortalContext.js";
import { setToken, setTokenProvider } from "./authTokenProvider.js";
import { setApiBaseUrlOverride, setOauthBaseUrlOverride } from "./env.js";
// Inline CSS for shadow root injection (kept separate from exported style.css)
import fontPickerCss from "react-fontpicker-ts/dist/index.css?raw";
function mirrorSonnerStylesToShadow(shadow) {
    const copyOnce = () => {
        if (shadow.querySelector("style[data-sonner-style]"))
            return;
        document.head.querySelectorAll("style").forEach((styleEl) => {
            const css = styleEl.textContent || "";
            if (css.includes("[data-sonner-toaster]")) {
                const clone = styleEl.cloneNode(true);
                clone.setAttribute("data-sonner-style", "");
                const head = shadow.querySelector("head");
                (head ?? shadow).appendChild(clone);
            }
        });
    };
    copyOnce();
    const mo = new MutationObserver(() => copyOnce());
    mo.observe(document.head, { childList: true, subtree: true });
    return () => mo.disconnect();
}
function adaptCssForShadow(css) {
    try {
        let out = css;
        out = out.replace(/:root(?![\w-])/g, ":host");
        out = out.replace(/(^|[\s,{])html(?![\w-])/g, "$1:host");
        out = out.replace(/(^|[\s,{])body(?![\w-])/g, "$1:host");
        return out;
    }
    catch {
        return css;
    }
}
function mirrorLibraryStylesToShadow(shadow, head) {
    const CODEPRESS_SENTINEL = "codepress:globals";
    const addStyleElement = (styleEl) => {
        if (shadow.querySelector('style[data-codepress-style="globals"]'))
            return;
        const css = styleEl.textContent || "";
        const style = document.createElement("style");
        style.textContent = adaptCssForShadow(css);
        style.setAttribute("data-codepress-style", "globals");
        (head ?? shadow).appendChild(style);
    };
    const addLinkElement = async (linkEl) => {
        const href = linkEl.getAttribute("href");
        if (!href)
            return;
        if (shadow.querySelector('link[data-codepress-style="globals-link"][href="' + href + '"]') ||
            shadow.querySelector('style[data-codepress-style="globals"]'))
            return;
        const link = document.createElement("link");
        link.rel = "stylesheet";
        link.href = href;
        link.setAttribute("data-codepress-style", "globals-link");
        (head ?? shadow).appendChild(link);
    };
    const copyOnce = () => {
        if (head.dataset?.codepressGlobals === "true")
            return;
        // Prefer a <style> tag injected by bundlers; fallback to <link> tag
        const styleEls = Array.from(document.head.querySelectorAll("style"));
        for (const styleEl of styleEls) {
            const css = styleEl.textContent || "";
            if (css.includes(CODEPRESS_SENTINEL) ||
                css.includes("[data-codepress-editing")) {
                addStyleElement(styleEl);
                return;
            }
        }
        const links = Array.from(document.head.querySelectorAll('link[rel="stylesheet"]'));
        // Try style.css first
        const libLink = links.find((l) => (l.getAttribute("href") || "").includes("/style.css"));
        if (libLink) {
            addLinkElement(libLink);
            return;
        }
        // Otherwise scan all links
        links.forEach((l) => addLinkElement(l));
    };
    copyOnce();
    const mo = new MutationObserver(() => copyOnce());
    mo.observe(document.head, { childList: true, subtree: true });
    return () => mo.disconnect();
}
function injectModuleRelativeCss(_shadow, _head) {
    // Manual CSS injection is disabled in the no-CSS build.
    // Import '@quantfive/codepress-browser-extension/style.css' in your host app instead.
}
export function CodepressEditor({ container, apiBaseUrl, oauthBaseUrl, token, tokenProvider, demo = false, useShadow = false, }) {
    const hostRef = React.useRef(null);
    const shadowRef = React.useRef(null);
    const rootRef = React.useRef(null);
    React.useEffect(() => {
        if (typeof window === "undefined")
            return; // SSR guard
        // Apply runtime overrides
        if (apiBaseUrl)
            setApiBaseUrlOverride(apiBaseUrl);
        if (oauthBaseUrl)
            setOauthBaseUrlOverride(oauthBaseUrl);
        if (tokenProvider)
            setTokenProvider(tokenProvider);
        if (typeof token !== "undefined")
            setToken(token);
        const targetParent = container ?? document.body;
        const host = document.createElement("div");
        hostRef.current = host;
        targetParent.appendChild(host);
        // If using shadow root, create and style inside it. Otherwise, render directly.
        const shadow = useShadow ? host.attachShadow({ mode: "open" }) : null;
        if (shadow)
            shadowRef.current = shadow;
        // Create a head container if shadow is used
        const head = shadow ? document.createElement("head") : null;
        if (head && shadow)
            shadow.appendChild(head);
        // Tailwind's own preflight in the compiled style.css will provide all runtime vars
        if (useShadow && head && shadow) {
            // Inject dependency styles directly (font picker) only in shadow mode
            const cssText = `${fontPickerCss}`;
            try {
                // Prefer Constructable Stylesheets for performance
                const adopted = shadow.adoptedStyleSheets;
                if (adopted && typeof CSSStyleSheet !== "undefined") {
                    const sheet = new CSSStyleSheet();
                    sheet.replaceSync(cssText);
                    shadow.adoptedStyleSheets = [...adopted, sheet];
                }
                else {
                    const styleEl = document.createElement("style");
                    styleEl.textContent = cssText;
                    styleEl.setAttribute("data-codepress-style", "deps");
                    head.appendChild(styleEl);
                }
            }
            catch {
                const styleEl = document.createElement("style");
                styleEl.textContent = cssText;
                styleEl.setAttribute("data-codepress-style", "deps");
                head.appendChild(styleEl);
            }
        }
        // In shadow mode, load compiled CSS into the shadow head. In non-shadow mode,
        // we expect the host app to import the package CSS directly.
        const disconnectLibraryMirror = useShadow && head && shadow
            ? (injectModuleRelativeCss(shadow, head),
                mirrorLibraryStylesToShadow(shadow, head))
            : null;
        if (head) {
            const envStyle = document.createElement("style");
            envStyle.textContent = `
        [data-codepress-root] {
          position: relative;
        }
      `;
            head.appendChild(envStyle);
        }
        // Create a container for app and portal
        const body = shadow ? document.createElement("div") : host;
        if (shadow)
            shadow.appendChild(body);
        const portalHost = document.createElement("div");
        portalHost.setAttribute("data-codepress-portal", "");
        body.appendChild(portalHost);
        // App container with namespacing id for CSS prefixing
        const app = document.createElement("div");
        app.id = "codepress-ui-editor";
        body.appendChild(app);
        // Mirror Sonner styles only when shadow is used
        const disconnect = shadow ? mirrorSonnerStylesToShadow(shadow) : undefined;
        const root = ReactDOM.createRoot(app);
        rootRef.current = root;
        root.render(_jsxs(PortalProvider, { container: portalHost, children: [_jsx("div", { "data-codepress-portal": "", children: _jsx(Toaster, { richColors: true, position: "top-center", closeButton: true }) }), _jsx(Editor, { demo: demo })] }));
        return () => {
            try {
                disconnect?.();
            }
            catch { }
            try {
                disconnectLibraryMirror?.();
            }
            catch { }
            try {
                rootRef.current?.unmount();
            }
            catch { }
            if (hostRef.current && hostRef.current.parentNode) {
                hostRef.current.parentNode.removeChild(hostRef.current);
            }
            hostRef.current = null;
            shadowRef.current = null;
            rootRef.current = null;
        };
    }, [container, apiBaseUrl, oauthBaseUrl, token, tokenProvider, demo]);
    return null;
}
export default CodepressEditor;
