import { DEFAULT_ENVIRONMENT as _ } from "./index191.js";
import { getGlobalScope as E } from "./index120.js";
import { notifyEventProcessors as D } from "./index211.js";
import { Scope as y } from "./index96.js";
import { mergeScopeData as d, applyScopeDataToEvent as S } from "./index219.js";
import { getFilenameToDebugIdMap as M } from "./index220.js";
import { uuid4 as k, addExceptionMechanism as I } from "./index121.js";
import { normalize as i } from "./index133.js";
import { truncate as P } from "./index152.js";
import { dateTimestampInSeconds as h } from "./index207.js";
function K(t, e, s, o, a, m) {
  const { normalizeDepth: n = 3, normalizeMaxBreadth: l = 1e3 } = t, c = {
    ...e,
    event_id: e.event_id || s.event_id || k(),
    timestamp: e.timestamp || h()
  }, g = s.integrations || t.integrations.map((r) => r.name);
  z(c, t), F(c, g), a && a.emit("applyFrameMetadata", e), e.type === void 0 && O(c, t.stackParser);
  const f = j(o, s.captureContext);
  s.mechanism && I(c, s.mechanism);
  const b = a ? a.getEventProcessors() : [], u = E().getScopeData();
  if (m) {
    const r = m.getScopeData();
    d(u, r);
  }
  if (f) {
    const r = f.getScopeData();
    d(u, r);
  }
  const p = [...s.attachments || [], ...u.attachments];
  p.length && (s.attachments = p), S(c, u);
  const x = [
    ...b,
    // Run scope event processors _after_ all other processors
    ...u.eventProcessors
  ];
  return D(x, c, s).then((r) => (r && T(r), typeof n == "number" && n > 0 ? C(r, n, l) : r));
}
function z(t, e) {
  const { environment: s, release: o, dist: a, maxValueLength: m = 250 } = e;
  t.environment = t.environment || s || _, !t.release && o && (t.release = o), !t.dist && a && (t.dist = a);
  const n = t.request;
  n?.url && (n.url = P(n.url, m));
}
function O(t, e) {
  const s = M(e);
  t.exception?.values?.forEach((o) => {
    o.stacktrace?.frames?.forEach((a) => {
      a.filename && (a.debug_id = s[a.filename]);
    });
  });
}
function T(t) {
  const e = {};
  if (t.exception?.values?.forEach((o) => {
    o.stacktrace?.frames?.forEach((a) => {
      a.debug_id && (a.abs_path ? e[a.abs_path] = a.debug_id : a.filename && (e[a.filename] = a.debug_id), delete a.debug_id);
    });
  }), Object.keys(e).length === 0)
    return;
  t.debug_meta = t.debug_meta || {}, t.debug_meta.images = t.debug_meta.images || [];
  const s = t.debug_meta.images;
  Object.entries(e).forEach(([o, a]) => {
    s.push({
      type: "sourcemap",
      code_file: o,
      debug_id: a
    });
  });
}
function F(t, e) {
  e.length > 0 && (t.sdk = t.sdk || {}, t.sdk.integrations = [...t.sdk.integrations || [], ...e]);
}
function C(t, e, s) {
  if (!t)
    return null;
  const o = {
    ...t,
    ...t.breadcrumbs && {
      breadcrumbs: t.breadcrumbs.map((a) => ({
        ...a,
        ...a.data && {
          data: i(a.data, e, s)
        }
      }))
    },
    ...t.user && {
      user: i(t.user, e, s)
    },
    ...t.contexts && {
      contexts: i(t.contexts, e, s)
    },
    ...t.extra && {
      extra: i(t.extra, e, s)
    }
  };
  return t.contexts?.trace && o.contexts && (o.contexts.trace = t.contexts.trace, t.contexts.trace.data && (o.contexts.trace.data = i(t.contexts.trace.data, e, s))), t.spans && (o.spans = t.spans.map((a) => ({
    ...a,
    ...a.data && {
      data: i(a.data, e, s)
    }
  }))), t.contexts?.flags && o.contexts && (o.contexts.flags = i(t.contexts.flags, 3, s)), o;
}
function j(t, e) {
  if (!e)
    return t;
  const s = t ? t.clone() : new y();
  return s.update(e), s;
}
function Q(t) {
}
export {
  z as applyClientOptions,
  O as applyDebugIds,
  T as applyDebugMeta,
  Q as parseEventHintOrCaptureContext,
  K as prepareEvent
};
