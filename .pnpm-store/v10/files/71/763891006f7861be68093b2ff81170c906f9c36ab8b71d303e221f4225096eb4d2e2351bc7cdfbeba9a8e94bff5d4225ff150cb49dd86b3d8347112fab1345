import { API_BASE_URL, BASE_LOCAL_CODEPRESS_DEPRECATED, checkGithubMode, } from "@/lib/env";
import Sentry from "@/sentry";
import { apiFetch, POST_CONFIG } from "../fetch.js";
import logger from "../lib/logger.js";
import { detectRepositoryInfo } from "../lib/utils.js";
/**
 * Creates a clean version of an HTML element by removing any injected UI components
 * Used to capture the original state of elements before modification
 *
 * @param element The element to clean
 * @param preserveDataFp Whether to preserve the codepress-data-fp attribute (default: false)
 */
export const getCleanElementHTML = (element, preserveDataFp = false) => {
    // For text content elements we need to extract the original text content
    const originalText = element.textContent || "";
    // Also get the original innerHTML
    const originalInnerHTML = element.innerHTML;
    // Get the element tag name
    const tagName = element.tagName.toLowerCase();
    // Get all original attributes
    const attributes = {};
    for (let i = 0; i < element.attributes.length; i++) {
        const attr = element.attributes[i];
        const attrName = attr.name.toLowerCase();
        let attrValue = attr.value;
        if (attrName.startsWith("data-cpt-") ||
            attrName === "contenteditable" ||
            attrName.includes("data-codepress") ||
            attrName.includes("codepress-data")) {
            continue; // Skip these attributes entirely
        }
        if (attrName === "codepress-data-fp" && !preserveDataFp) {
            continue; // Skip codepress-data-fp if not preserving
        }
        if (attrName === "style") {
            const styleProperties = attrValue
                .split(";")
                .map((s) => s.trim())
                .filter((s) => s !== ""); // Remove empty strings
            const cleanedProperties = styleProperties.filter((prop) => {
                // Test if the property starts with 'cursor:' followed by 'text', case-insensitive
                return !/^cursor\s*:\s*text/i.test(prop);
            });
            attrValue = cleanedProperties.join("; ");
            if (!attrValue) {
                continue; // Don't add an empty style attribute
            }
        }
        attributes[attrName] = attrValue;
    }
    // Build a new clean element
    const tempDiv = document.createElement("div");
    const cleanEl = document.createElement(tagName);
    // Copy over all the original attributes
    Object.entries(attributes).forEach(([name, value]) => {
        cleanEl.setAttribute(name, value);
    });
    // For image tags, preserve the src attribute
    if (tagName === "img") {
        const imgSrc = element.getAttribute("src");
        if (imgSrc) {
            cleanEl.setAttribute("src", imgSrc);
        }
        const imgAlt = element.getAttribute("alt");
        if (imgAlt) {
            cleanEl.setAttribute("alt", imgAlt);
        }
    }
    else {
        // For non-image elements, restore the original innerHTML
        cleanEl.innerHTML = originalInnerHTML;
    }
    tempDiv.appendChild(cleanEl);
    return tempDiv.innerHTML;
};
export const getPreviewLink = async (info) => {
    try {
        const repoInfo = detectRepositoryInfo();
        // Call the API using our new fetch utilities
        const config = await POST_CONFIG({
            data: {
                repo_name: repoInfo?.repository,
                branch_name: info?.branchName,
            },
            includeAuth: true,
        });
        // Check localStorage for GitHub mode setting
        const githubMode = checkGithubMode();
        const url = githubMode
            ? `${API_BASE_URL}/code-sync/preview`
            : `${API_BASE_URL}/code-sync/preview`;
        logger.log(`[getPreviewLink] GitHub mode: ${githubMode}, using URL: ${url}`);
        const res = await apiFetch(url, config);
        if (!res.ok)
            throw new Error("Failed to fetch preview data");
        const data = await res.json();
        return data;
    }
    catch (error) {
        logger.error("Error getting preview:", error);
        Sentry.captureException(error);
        return {};
    }
};
export const getBranches = async () => {
    const repoInfo = detectRepositoryInfo();
    const url = `${API_BASE_URL}/code-sync/branches`;
    // Call the API using our new fetch utilities
    const config = await POST_CONFIG({
        data: {
            repo_name: repoInfo?.repository,
        },
        includeAuth: true,
    });
    const res = await apiFetch(url, config);
    if (!res.ok)
        throw new Error("Failed to fetch preview data");
    const data = await res.json();
    return data;
};
export const deleteGithubBranch = async (info) => {
    const repoInfo = detectRepositoryInfo();
    const url = `${API_BASE_URL}/code-sync/delete`;
    // Call the API using our new fetch utilities
    const config = await POST_CONFIG({
        data: {
            repo_name: repoInfo?.repository,
            branch_name: info.branchName,
        },
        includeAuth: true,
    });
    const res = await apiFetch(url, config);
    if (!res.ok)
        throw new Error("Failed to fetch preview data");
    const data = await res.json();
    return data;
};
export const saveVisualEditorChanges = async (changes) => {
    try {
        // Dispatch custom event
        const changeEvent = new CustomEvent("elementChanged", {
            detail: changes,
            bubbles: true,
            composed: true,
        });
        document.dispatchEvent(changeEvent);
        // Call the API using our new fetch utilities
        const config = await POST_CONFIG({
            data: changes,
            includeAuth: true,
        });
        // Check localStorage for GitHub mode setting
        const githubMode = checkGithubMode();
        const url = githubMode
            ? `${API_BASE_URL}/code-sync/update-file`
            : `${BASE_LOCAL_CODEPRESS_DEPRECATED}/visual-editor-api`;
        logger.debug(`[saveVisualEditorChanges] GitHub mode: ${githubMode}, using URL: ${url}`);
        const results = await apiFetch(url, config);
        if (!results?.ok) {
            logger.error("Error saving changes:", results);
        }
        return !!results?.ok;
    }
    catch (error) {
        logger.error("Error saving changes:", error);
        Sentry.captureException(error);
        return false;
    }
};
export const saveAiChanges = async (changes) => {
    // Dispatch custom event first
    const changeEvent = new CustomEvent("aiElementChanged", {
        detail: changes,
        bubbles: true,
        composed: true,
    });
    document.dispatchEvent(changeEvent);
    // Call the API using our fetch utilities
    const config = await POST_CONFIG({
        data: changes,
        includeAuth: true,
    });
    // Check localStorage for GitHub mode setting
    const githubMode = checkGithubMode();
    const baseUrl = githubMode ? API_BASE_URL : BASE_LOCAL_CODEPRESS_DEPRECATED;
    logger.debug(`[saveAiChanges] GitHub mode: ${githubMode}, using URL: ${baseUrl}`);
    // The visual-editor-api will recognize the mode and handle accordingly
    const response = await apiFetch(`${baseUrl}/visual-editor-api`, config);
    if (!response.ok) {
        throw new Error(`API request failed with status ${response.status}`);
    }
    const result = await response.json();
    return result;
};
