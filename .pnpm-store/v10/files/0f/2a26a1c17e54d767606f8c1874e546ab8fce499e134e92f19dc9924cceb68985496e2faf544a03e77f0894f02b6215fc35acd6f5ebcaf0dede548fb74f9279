import { getDefaultCurrentScope as p, getDefaultIsolationScope as S } from "./index204.js";
import { Scope as s } from "./index96.js";
import { isThenable as a } from "./index132.js";
import { getMainCarrier as h, getSentryCarrier as u } from "./index202.js";
class l {
  constructor(t, n) {
    let c;
    t ? c = t : c = new s();
    let o;
    n ? o = n : o = new s(), this._stack = [{ scope: c }], this._isolationScope = o;
  }
  /**
   * Fork a scope for the stack.
   */
  withScope(t) {
    const n = this._pushScope();
    let c;
    try {
      c = t(n);
    } catch (o) {
      throw this._popScope(), o;
    }
    return a(c) ? c.then(
      (o) => (this._popScope(), o),
      (o) => {
        throw this._popScope(), o;
      }
    ) : (this._popScope(), c);
  }
  /**
   * Get the client of the stack.
   */
  getClient() {
    return this.getStackTop().client;
  }
  /**
   * Returns the scope of the top stack.
   */
  getScope() {
    return this.getStackTop().scope;
  }
  /**
   * Get the isolation scope for the stack.
   */
  getIsolationScope() {
    return this._isolationScope;
  }
  /**
   * Returns the topmost scope layer in the order domain > local > process.
   */
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  /**
   * Push a scope to the stack.
   */
  _pushScope() {
    const t = this.getScope().clone();
    return this._stack.push({
      client: this.getClient(),
      scope: t
    }), t;
  }
  /**
   * Pop a scope from the stack.
   */
  _popScope() {
    return this._stack.length <= 1 ? !1 : !!this._stack.pop();
  }
}
function r() {
  const e = h(), t = u(e);
  return t.stack = t.stack || new l(p(), S());
}
function g(e) {
  return r().withScope(e);
}
function f(e, t) {
  const n = r();
  return n.withScope(() => (n.getStackTop().scope = e, t(e)));
}
function i(e) {
  return r().withScope(() => e(r().getIsolationScope()));
}
function y() {
  return {
    withIsolationScope: i,
    withScope: g,
    withSetScope: f,
    withSetIsolationScope: (e, t) => i(t),
    getCurrentScope: () => r().getScope(),
    getIsolationScope: () => r().getIsolationScope()
  };
}
export {
  l as AsyncContextStack,
  y as getStackAsyncContextStrategy
};
