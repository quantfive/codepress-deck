import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React from "react";
import { Controller } from "react-hook-form";
import { Card, CardContent } from "./ui/card.js";
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger, } from "./ui/accordion.js";
import { Input } from "./ui/input.js";
import { Label } from "./ui/label.js";
import { Slider } from "./ui/slider.js";
import { Button } from "./ui/button.js";
import { ToggleGroup, ToggleGroupItem } from "./ui/toggle-group.js";
import { Select, SelectTrigger, SelectValue, SelectContent, SelectItem, } from "./ui/select.js";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faAlignLeft, faAlignCenter, faAlignRight, faAlignJustify, faTimes, faSpinnerThird, faUpload, faSearch, } from "@fortawesome/pro-regular-svg-icons";
import { Popover, PopoverContent, PopoverTrigger } from "./ui/popover.js";
import { ColorPickerContent } from "./ColorPickerContent.js";
import { detectRepositoryInfo } from "../lib/utils.js";
import { useVisualEditor } from "../context/VisualEditorContext.js";
import { API_BASE_URL, BASE_LOCAL_CODEPRESS_DEPRECATED, checkGithubMode, IS_DEVELOPMENT } from "@/lib/env";
import { POST_CONFIG, apiFetch, } from "../fetch.js";
import Sentry from "@/sentry";
import { useGitHub } from "@/context/GithubContext";
export function DesignPanel({ onClose, shadowRoot }) {
    const { control, watch, setValue, getValues, updateActiveElementStyle, activeElementFpId, trackedElements, } = useVisualEditor();
    const { isGitHubMode, setIsGitHubMode, } = useGitHub();
    const activeTrackedElement = activeElementFpId
        ? trackedElements[activeElementFpId]
        : null;
    const element = activeTrackedElement?.element;
    // Track if image upload is in progress
    const [isUploading, setIsUploading] = React.useState(false);
    // Track if edit mode is disabled (turns off inline edit and highlighter)
    const [isEditModeDisabled, setIsEditModeDisabled] = React.useState(false);
    // Track if AI editor is open
    const [isAIEditorOpen, setIsAIEditorOpen] = React.useState(false);
    // Track AI input and output
    const [aiInput, setAiInput] = React.useState("");
    const [aiOutput, setAiOutput] = React.useState("");
    const [isAiProcessing, setIsAiProcessing] = React.useState(false);
    // Track image preview
    const [imagePreview, setImagePreview] = React.useState(null);
    // Reference to the floating panel & its position
    const panelRef = React.useRef(null);
    const [position, setPosition] = React.useState({ x: 0, y: 0 });
    // Helper clamp util (mirrors DesignBar for collision-avoidance)
    const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
    // Compute floating panel position relative to active element with collision avoidance
    React.useEffect(() => {
        const el = element;
        if (!el)
            return;
        const computePosition = () => {
            const rect = el.getBoundingClientRect();
            const margin = 16;
            const gap = 16;
            const scrollX = window.scrollX;
            const scrollY = window.scrollY;
            // Use actual dimensions when available
            const panelWidth = panelRef.current?.offsetWidth || 320;
            const panelHeight = panelRef.current?.offsetHeight || 600;
            // Prefer showing to the right of the element
            let x = rect.right + gap + scrollX;
            if (x + panelWidth + margin > window.innerWidth + scrollX) {
                // Not enough space on the right, try left
                x = rect.left - panelWidth - gap + scrollX;
                // Clamp if still overflowing
                x = clamp(x, margin + scrollX, window.innerWidth - panelWidth - margin + scrollX);
            }
            // Vertical position aligned with element top, clamped to viewport
            let y = rect.top + scrollY;
            y = clamp(y, margin + scrollY, window.innerHeight - panelHeight - margin + scrollY);
            setPosition({ x, y });
        };
        computePosition();
        // Recompute once DOM renders to capture actual dimensions
        setTimeout(computePosition, 0);
        // Update on window resize so the panel doesn't end up off-screen
        const handleResize = () => computePosition();
        window.addEventListener("resize", handleResize);
        return () => {
            window.removeEventListener("resize", handleResize);
        };
    }, [element]);
    const values = watch();
    // Use regular state for tab switching (not form state)
    const [currentState, setCurrentState] = React.useState("normal");
    // Track if codebase indexing is in progress
    const [isIndexing, setIsIndexing] = React.useState(false);
    // Track codebase indexing result
    const [indexingResult, setIndexingResult] = React.useState("");
    const [showBackgroundPicker, setShowBackgroundPicker] = React.useState(false);
    const [showColorPicker, setShowColorPicker] = React.useState(false);
    const [tempBackgroundColor, setTempBackgroundColor] = React.useState("");
    const [tempColor, setTempColor] = React.useState("");
    // Helper function to get the property name based on current state
    const getPropertyName = (baseProp) => {
        if (currentState === "hover") {
            return `hover_${baseProp}`;
        }
        return baseProp;
    };
    // Helper function to get the current value for a property
    const getCurrentValue = (baseProp) => {
        const propName = getPropertyName(baseProp);
        return values[propName];
    };
    // Helper function to set a value for the current state
    const setCurrentValue = (baseProp, value) => {
        const propName = getPropertyName(baseProp);
        // Expand shorthand spacing / border props to keep individual sides in sync
        const mirrorSides = (base, val) => {
            ["Top", "Right", "Bottom", "Left"].forEach((side) => {
                const sideProp = getPropertyName(`${base}${side}`);
                setValue(sideProp, val);
            });
        };
        const parseBoxShorthand = (val) => {
            const parts = val.trim().split(/\s+/);
            switch (parts.length) {
                case 1:
                    return [parts[0], parts[0], parts[0], parts[0]];
                case 2:
                    return [parts[0], parts[1], parts[0], parts[1]];
                case 3:
                    return [parts[0], parts[1], parts[2], parts[1]];
                case 4:
                    return [parts[0], parts[1], parts[2], parts[3]];
                default:
                    return [val, val, val, val];
            }
        };
        if ((baseProp === "padding" || baseProp === "margin") &&
            typeof value === "string") {
            const [top, right, bottom, left] = parseBoxShorthand(value);
            mirrorSides(baseProp, value); // still mirror shorthand value (for consistency)
            const sidesMap = {
                padding: [top, right, bottom, left],
                margin: [top, right, bottom, left],
            };
            ["Top", "Right", "Bottom", "Left"].forEach((side, idx) => {
                const sideProp = getPropertyName(`${baseProp}${side}`);
                setValue(sideProp, sidesMap[baseProp][idx]);
            });
        }
        else if (baseProp === "border") {
            mirrorSides(baseProp, value);
        }
        // If an individual side prop changes, check if all sides are equal â†’ update shorthand
        const sideGroups = {
            padding: ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
            margin: ["marginTop", "marginRight", "marginBottom", "marginLeft"],
            border: ["borderTop", "borderRight", "borderBottom", "borderLeft"],
        };
        Object.entries(sideGroups).forEach(([shorthand, sides]) => {
            if (sides.includes(baseProp)) {
                // Get current values for all sides (including the updated one)
                const sideVals = sides.map((s) => s === baseProp ? value : getCurrentValue(s));
                const [top, right, bottom, left] = sideVals;
                let shorthandValue = "";
                if (sideVals.every((v) => v === top)) {
                    shorthandValue = top;
                }
                else if (top === bottom && right === left) {
                    shorthandValue = `${top} ${right}`;
                }
                else if (right === left) {
                    shorthandValue = `${top} ${right} ${bottom}`;
                }
                else {
                    shorthandValue = `${top} ${right} ${bottom} ${left}`;
                }
                const shorthandProp = getPropertyName(shorthand);
                setValue(shorthandProp, shorthandValue);
            }
        });
        // Finally set the requested prop itself
        setValue(propName, value);
    };
    const handleColorPickerCancel = (type) => {
        // Reverting is now handled globally by cancelAllChanges,
        // but we can close the picker.
        if (type === "background") {
            setShowBackgroundPicker(false);
            setTempBackgroundColor("");
        }
        else {
            setShowColorPicker(false);
            setTempColor("");
        }
        // No need to dispatch events, cancelAllChanges will revert everything if needed.
    };
    const handleColorPickerSave = (type, color) => {
        const baseProp = type === "background" ? "backgroundColor" : "color";
        const propName = getPropertyName(baseProp);
        if (type === "background") {
            setShowBackgroundPicker(false);
            setTempBackgroundColor("");
        }
        else {
            setShowColorPicker(false);
            setTempColor("");
        }
        setValue(propName, color);
    };
    // Handle image upload
    const handleImageUpload = async (event, type = "background") => {
        const files = event.target.files;
        if (!files || files.length === 0)
            return;
        const file = files[0];
        const filename = file.name;
        if (!file.type.startsWith("image/")) {
            alert("Please select an image file");
            return;
        }
        if (file.size > 5 * 1024 * 1024) {
            alert("Image size should be less than 5MB");
            return;
        }
        try {
            setIsUploading(true);
            const reader = new FileReader();
            const dataUrl = await new Promise((resolve, reject) => {
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(new Error("Failed to read file"));
                reader.readAsDataURL(file);
            });
            const fieldName = type === "background" ? "backgroundImage" : "imageSrc";
            setValue(fieldName, dataUrl);
            setImagePreview(dataUrl);
        }
        catch (error) {
            Sentry.captureException(error);
            console.error("Error processing image:", error);
            alert("Failed to process image. Please try again.");
        }
        finally {
            setIsUploading(false);
            event.target.value = "";
        }
    };
    // Initialize image preview from existing backgroundImage
    React.useEffect(() => {
        if (values.backgroundImage) {
            setImagePreview(values.backgroundImage);
        }
        else if (values.imageSrc) {
            setImagePreview(values.imageSrc);
        }
        else {
            setImagePreview(null);
        }
    }, [values.backgroundImage, values.imageSrc]);
    // Handler for processing AI requests
    const handleAiRequest = async () => {
        if (!aiInput.trim() || isAiProcessing)
            return;
        setIsAiProcessing(true);
        setAiOutput("");
        try {
            if (!element) {
                setAiOutput("No element selected for modification.");
                return;
            }
            const hashId = element.getAttribute("codepress-data-fp");
            if (!hashId) {
                setAiOutput("This element doesn't have a file mapping. Please select a different element.");
                return;
            }
            const repoInfo = detectRepositoryInfo();
            const requestData = {
                encoded_location: hashId,
                ai_instruction: aiInput,
                github_repo_name: repoInfo?.repository,
                github_base_branch_name: repoInfo?.branch,
                additional_context: {
                    target_element_html: element?.outerHTML || undefined,
                },
            };
            const config = await POST_CONFIG({
                data: requestData,
                includeAuth: true,
            });
            // Check localStorage for GitHub mode setting
            const githubMode = checkGithubMode();
            const url = githubMode
                ? `${API_BASE_URL}/code-sync/get-ai-changes`
                : `${BASE_LOCAL_CODEPRESS_DEPRECATED}/visual-editor-api-ai`;
            const response = await apiFetch(url, config);
            if (!response.ok) {
                const errorData = await response.json().catch((e) => {
                    Sentry.captureException(e);
                });
                throw new Error(errorData.error || `API request failed with status ${response.status}`);
            }
            const result = await response.json();
            if (!result.success) {
                throw new Error(result.message || "Failed to process AI request");
            }
            setAiOutput(result.message || "Changes applied successfully!");
            if (result.modified_content) {
                const tempDiv = document.createElement("div");
                tempDiv.innerHTML = result.modified_content;
                if (tempDiv.firstElementChild) {
                    tempDiv.firstElementChild.setAttribute("codepress-data-fp", hashId);
                    element.outerHTML = tempDiv.firstElementChild.outerHTML;
                }
            }
        }
        catch (error) {
            Sentry.captureException(error);
            console.error("Error processing AI request:", error);
            setAiOutput(error instanceof Error
                ? error.message
                : "Sorry, there was an error processing your request. Please try again.");
        }
        finally {
            setIsAiProcessing(false);
        }
    };
    // Handler for indexing codebase
    const handleIndexCodebase = async () => {
        if (isIndexing)
            return;
        setIsIndexing(true);
        setIndexingResult("");
        try {
            const repoInfo = detectRepositoryInfo();
            if (!repoInfo || !repoInfo.repository) {
                setIndexingResult("No repository information found. Please ensure you're on a CodePress-enabled page.");
                return;
            }
            const requestData = {
                repository_name: repoInfo.repository,
                branch: repoInfo.branch || undefined,
            };
            const config = await POST_CONFIG({
                data: requestData,
                includeAuth: true,
            });
            const response = await apiFetch(`${API_BASE_URL}/code-sync/analyze-repository-style`, config);
            if (!response.ok) {
                const errorData = await response.json().catch((error) => {
                    Sentry.captureException(error);
                });
                throw new Error(errorData.detail ||
                    `API request failed with status ${response.status}`);
            }
            const result = await response.json();
            if (result.success) {
                setIndexingResult(`Successfully indexed ${result.total_files} files from ${result.repository_name}. The codebase analysis has been cached for faster AI suggestions.`);
            }
            else {
                throw new Error(result.message || "Failed to index codebase");
            }
        }
        catch (error) {
            Sentry.captureException(error);
            console.error("Error indexing codebase:", error);
            setIndexingResult(error instanceof Error
                ? error.message
                : "Sorry, there was an error indexing the codebase. Please try again.");
        }
        finally {
            setIsIndexing(false);
        }
    };
    if (!element) {
        return (_jsx("div", { id: "codepress-ui", className: "fixed top-0 right-0 h-full w-80 bg-white border-l border-gray-200 shadow-lg z-[10000] p-4 flex items-center justify-center", children: _jsx("div", { className: "text-center", children: _jsx("p", { className: "text-gray-500", children: "Select an element on the page to start editing." }) }) }));
    }
    // Add fade-in animation keyframes (once)
    const fadeInKeyframesPanel = `@keyframes fadeInDesignPanel { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }`;
    if (typeof document !== "undefined") {
        const styleId = "codepress-designpanel-fadein";
        if (!document.getElementById(styleId)) {
            const style = document.createElement("style");
            style.id = styleId;
            style.textContent = fadeInKeyframesPanel;
            document.head.appendChild(style);
        }
    }
    return (_jsx("div", { id: "codepress-ui", ref: panelRef, className: "absolute bg-white rounded-lg shadow-2xl border border-gray-200 z-[2147483647] overflow-y-auto", style: {
            top: `${position.y}px`,
            left: `${position.x}px`,
            width: "320px",
            maxHeight: "80vh",
            animation: "fadeInDesignPanel 0.15s ease-out forwards",
            backgroundColor: "white",
        }, children: _jsx(Card, { className: "w-full shadow-none border-none h-full", children: _jsxs(CardContent, { className: "p-4", children: [_jsxs("div", { className: "flex justify-between items-center mb-4 relative", children: [_jsxs("div", { className: "flex flex-col items-start gap-2", children: [_jsx("h2", { className: "text-lg font-semibold", children: "CodePress" }), _jsxs("div", { className: "flex text-xs items-center gap-3", children: [_jsxs("div", { className: "flex items-center gap-1", children: [_jsx("label", { htmlFor: "edit-mode-toggle", className: "text-xs text-gray-500", children: "Edit Mode" }), _jsx("input", { id: "edit-mode-toggle", type: "checkbox", checked: !isEditModeDisabled, onChange: (e) => {
                                                            setIsEditModeDisabled(!e.target.checked);
                                                            // Dispatch an event to notify content script
                                                            const event = new CustomEvent("codepress-toggle-inline-edit", {
                                                                detail: { disabled: !e.target.checked },
                                                                bubbles: true,
                                                                composed: true,
                                                            });
                                                            document.dispatchEvent(event);
                                                        }, className: "h-3 w-3" })] }), IS_DEVELOPMENT && (_jsxs("div", { className: "flex items-center gap-1", children: [_jsx("label", { htmlFor: "github-mode-toggle", className: "text-xs text-gray-500", children: "GitHub Mode" }), _jsx("input", { id: "github-mode-toggle", type: "checkbox", checked: isGitHubMode, onChange: (e) => {
                                                            setIsGitHubMode(e.target.checked);
                                                            // Dispatch an event to notify about GitHub mode change
                                                            const event = new CustomEvent("codepress-toggle-github-mode", {
                                                                detail: { enabled: e.target.checked },
                                                                bubbles: true,
                                                                composed: true,
                                                            });
                                                            document.dispatchEvent(event);
                                                        }, className: "h-3 w-3" })] }))] })] }), _jsx(Button, { variant: "ghost", size: "sm", className: "p-2 absolute -right-2 -top-2", onClick: onClose, children: _jsx(FontAwesomeIcon, { icon: faTimes, className: "h-4 w-4" }) })] }), _jsxs("div", { className: "mb-4", children: [_jsx(Label, { className: "text-sm font-medium mb-2 block", children: "CSS State" }), _jsxs(ToggleGroup, { type: "single", value: currentState, onValueChange: (value) => {
                                    if (value) {
                                        setCurrentState(value);
                                        // When switching states, we don't trigger unsaved changes
                                        // because we're just switching views
                                    }
                                }, className: "w-full", children: [_jsx(ToggleGroupItem, { value: "normal", className: "flex-1 data-[state=on]:bg-amber-500/20 data-[state=on]:border-amber-500", children: "Normal" }), _jsx(ToggleGroupItem, { value: "hover", className: "flex-1 data-[state=on]:bg-amber-500/20 data-[state=on]:border-amber-500", children: "Hover" })] })] }), _jsxs("div", { className: "mb-4", children: [_jsx(Button, { className: "w-full mb-2 bg-gradient-to-r from-purple-600 to-blue-500 hover:from-purple-700 hover:to-blue-600 text-white", onClick: () => setIsAIEditorOpen(!isAIEditorOpen), children: isAIEditorOpen ? "Close CodePress Max" : "Open CodePress Max" }), isAIEditorOpen && (_jsxs("div", { className: "border border-gray-200 dark:border-gray-700 rounded-md p-3 space-y-3 bg-gray-50 dark:bg-gray-800", children: [_jsxs("form", { onSubmit: (e) => {
                                            e.preventDefault();
                                            handleAiRequest();
                                        }, className: "space-y-3", children: [_jsxs("div", { className: "space-y-2", children: [_jsx(Label, { htmlFor: "ai-input", className: "text-gray-700 dark:text-gray-300", children: "Describe your changes" }), _jsx("textarea", { id: "ai-input", className: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded h-20 resize-none bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 placeholder-gray-500 dark:placeholder-gray-400", placeholder: "E.g., 'Make the text larger' or 'Change the color to blue'", value: aiInput, onChange: (e) => setAiInput(e.target.value), disabled: isAiProcessing, onKeyDown: (e) => {
                                                            // Submit on Enter, but allow Shift+Enter for new lines
                                                            if (e.key === "Enter" && !e.shiftKey) {
                                                                e.preventDefault();
                                                                handleAiRequest();
                                                            }
                                                        } })] }), _jsxs(Button, { type: "submit", className: "w-full bg-amber-500 hover:bg-amber-600 text-black", disabled: !aiInput.trim() || isAiProcessing, children: [isAiProcessing ? (_jsx(FontAwesomeIcon, { icon: faSpinnerThird, className: "h-4 w-4 animate-spin mr-2" })) : null, isAiProcessing ? "Processing..." : "Apply Changes"] })] }), aiOutput && (_jsx("div", { className: "mt-3 p-3 border border-gray-200 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100", children: _jsx("p", { className: "text-sm", children: aiOutput }) }))] }))] }), _jsxs("div", { className: "mb-4", children: [_jsxs(Button, { className: "w-full mb-2 bg-gradient-to-r from-orange-500 to-red-500 hover:from-orange-600 hover:to-red-600 text-white", onClick: handleIndexCodebase, disabled: isIndexing, children: [isIndexing ? (_jsx(FontAwesomeIcon, { icon: faSpinnerThird, className: "h-4 w-4 animate-spin mr-2" })) : (_jsx(FontAwesomeIcon, { icon: faSearch, className: "h-4 w-4 mr-2" })), isIndexing ? "Indexing Codebase..." : "Index Codebase"] }), indexingResult && (_jsx("div", { className: "p-3 border border-gray-200 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100", children: _jsx("p", { className: "text-sm", children: indexingResult }) }))] }), _jsxs(Accordion, { type: "multiple", defaultValue: [
                            "position",
                            "transform",
                            "layout",
                            "appearance",
                            "typography",
                            "background",
                            "color",
                            "image",
                        ], children: [values.availableSections.typography && (_jsxs(AccordionItem, { value: "typography", children: [_jsx(AccordionTrigger, { children: "Typography" }), _jsx(AccordionContent, { children: _jsxs("div", { className: "space-y-4", children: [_jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Font Size" }), _jsx(Controller, { name: getPropertyName("fontSize"), control: control, render: ({ field }) => (_jsx(Input, { type: "text", ...field, value: field.value || "", onChange: (e) => field.onChange(e.target.value) })) })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Line Height" }), _jsx(Controller, { name: getPropertyName("lineHeight"), control: control, render: ({ field }) => (_jsx(Input, { type: "text", ...field, value: field.value || "", onChange: (e) => field.onChange(e.target.value) })) })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Letter Spacing" }), _jsx(Controller, { name: getPropertyName("letterSpacing"), control: control, render: ({ field }) => (_jsx(Input, { type: "text", ...field, value: field.value || "" })) })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Text Alignment" }), _jsx(Controller, { name: getPropertyName("textAlign"), control: control, render: ({ field }) => (_jsxs(ToggleGroup, { type: "single", value: field.value || "left", onValueChange: field.onChange, className: "justify-between w-full mt-1 cursor-pointer", children: [_jsx(ToggleGroupItem, { value: "left", className: "flex-1 data-[state=on]:bg-amber-500/20 data-[state=on]:border-amber-500", children: _jsx(FontAwesomeIcon, { icon: faAlignLeft, className: "h-4 w-4" }) }), _jsx(ToggleGroupItem, { value: "center", className: "flex-1 data-[state=on]:bg-amber-500/20 data-[state=on]:border-amber-500", children: _jsx(FontAwesomeIcon, { icon: faAlignCenter, className: "h-4 w-4" }) }), _jsx(ToggleGroupItem, { value: "right", className: "flex-1 data-[state=on]:bg-amber-500/20 data-[state=on]:border-amber-500", children: _jsx(FontAwesomeIcon, { icon: faAlignRight, className: "h-4 w-4" }) }), _jsx(ToggleGroupItem, { value: "justify", className: "flex-1 data-[state=on]:bg-amber-500/20 data-[state=on]:border-amber-500", children: _jsx(FontAwesomeIcon, { icon: faAlignJustify, className: "h-4 w-4" }) })] })) })] })] }) })] })), _jsxs("div", { className: "space-y-4", children: [_jsxs("div", { className: "flex items-center justify-between", children: [_jsx(Label, { children: "Spacing" }), _jsx(Button, { type: "button", variant: "ghost", size: "sm", onClick: () => {
                                                    const currentValue = getValues("showAdvancedSpacing");
                                                    setValue("showAdvancedSpacing", !currentValue);
                                                }, className: "text-xs", children: values.showAdvancedSpacing
                                                    ? "Hide Advanced"
                                                    : "Show Advanced" })] }), _jsxs("div", { className: "grid grid-cols-2 gap-4", children: [_jsxs("div", { className: "space-y-2", children: [_jsx(Label, { className: "text-xs", children: "Padding (All Sides)" }), _jsx(Controller, { name: getPropertyName("padding"), control: control, render: ({ field }) => (_jsx(Input, { type: "text", ...field, value: field.value || "", onChange: (e) => {
                                                                field.onChange(e.target.value);
                                                                // Update all padding sides when the main padding changes
                                                                setCurrentValue("padding", e.target.value);
                                                            } })) })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { className: "text-xs", children: "Margin (All Sides)" }), _jsx(Controller, { name: getPropertyName("margin"), control: control, render: ({ field }) => (_jsx(Input, { type: "text", ...field, value: field.value || "", onChange: (e) => {
                                                                field.onChange(e.target.value);
                                                                // Update all margin sides when the main margin changes
                                                                setCurrentValue("margin", e.target.value);
                                                            } })) })] })] }), values.showAdvancedSpacing && (_jsxs(_Fragment, { children: [_jsxs("div", { className: "space-y-2", children: [_jsx(Label, { className: "text-xs", children: "Padding (Individual Sides)" }), _jsxs("div", { className: "grid grid-cols-2 gap-4", children: [_jsxs("div", { className: "space-y-2", children: [_jsx(Label, { className: "text-xs", children: "Top" }), _jsx(Controller, { name: getPropertyName("paddingTop"), control: control, render: ({ field }) => (_jsx(Input, { type: "text", ...field, value: field.value || "", onChange: (e) => {
                                                                                field.onChange(e.target.value);
                                                                                setCurrentValue("paddingTop", e.target.value);
                                                                            } })) })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { className: "text-xs", children: "Right" }), _jsx(Controller, { name: getPropertyName("paddingRight"), control: control, render: ({ field }) => (_jsx(Input, { type: "text", ...field, value: field.value || "", onChange: (e) => {
                                                                                field.onChange(e.target.value);
                                                                                setCurrentValue("paddingRight", e.target.value);
                                                                            } })) })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { className: "text-xs", children: "Bottom" }), _jsx(Controller, { name: getPropertyName("paddingBottom"), control: control, render: ({ field }) => (_jsx(Input, { type: "text", ...field, value: field.value || "", onChange: (e) => {
                                                                                field.onChange(e.target.value);
                                                                                setCurrentValue("paddingBottom", e.target.value);
                                                                            } })) })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { className: "text-xs", children: "Left" }), _jsx(Controller, { name: getPropertyName("paddingLeft"), control: control, render: ({ field }) => (_jsx(Input, { type: "text", ...field, value: field.value || "", onChange: (e) => {
                                                                                field.onChange(e.target.value);
                                                                                setCurrentValue("paddingLeft", e.target.value);
                                                                            } })) })] })] })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { className: "text-xs", children: "Margin (Individual Sides)" }), _jsxs("div", { className: "grid grid-cols-2 gap-4", children: [_jsxs("div", { className: "space-y-2", children: [_jsx(Label, { className: "text-xs", children: "Top" }), _jsx(Controller, { name: "marginTop", control: control, render: ({ field }) => (_jsx(Input, { type: "text", ...field, value: field.value || "", onChange: (e) => {
                                                                                field.onChange(e.target.value);
                                                                                setValue("marginTop", e.target.value);
                                                                            } })) })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { className: "text-xs", children: "Right" }), _jsx(Controller, { name: "marginRight", control: control, render: ({ field }) => (_jsx(Input, { type: "text", ...field, value: field.value || "", onChange: (e) => {
                                                                                field.onChange(e.target.value);
                                                                                setValue("marginRight", e.target.value);
                                                                            } })) })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { className: "text-xs", children: "Bottom" }), _jsx(Controller, { name: "marginBottom", control: control, render: ({ field }) => (_jsx(Input, { type: "text", ...field, value: field.value || "", onChange: (e) => {
                                                                                field.onChange(e.target.value);
                                                                                setValue("marginBottom", e.target.value);
                                                                            } })) })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { className: "text-xs", children: "Left" }), _jsx(Controller, { name: "marginLeft", control: control, render: ({ field }) => (_jsx(Input, { type: "text", ...field, value: field.value || "", onChange: (e) => {
                                                                                field.onChange(e.target.value);
                                                                                setValue("marginLeft", e.target.value);
                                                                            } })) })] })] })] })] }))] }), values.availableSections.color && (_jsxs(AccordionItem, { value: "color", children: [_jsx(AccordionTrigger, { children: "Color" }), _jsx(AccordionContent, { children: _jsxs("div", { className: "space-y-4", children: [_jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Text Color" }), _jsxs("div", { className: "flex items-center gap-2", children: [_jsxs(Popover, { open: showColorPicker, onOpenChange: setShowColorPicker, children: [_jsx(PopoverTrigger, { asChild: true, children: _jsx("div", { className: "w-10 h-10 rounded border cursor-pointer relative", style: {
                                                                                    backgroundColor: tempColor || getCurrentValue("color"),
                                                                                } }) }), _jsx(PopoverContent, { className: "w-auto p-0", align: "start", id: "codepress-text-color-picker-content", container: shadowRoot, style: { zIndex: 2147483647 }, children: _jsx(ColorPickerContent, { type: "text", color: getCurrentValue("color"), tempColor: tempColor, onColorChange: (color) => {
                                                                                    setTempColor(color);
                                                                                    updateActiveElementStyle({
                                                                                        [getPropertyName("color")]: color,
                                                                                    });
                                                                                }, onClose: () => handleColorPickerCancel("text"), onSave: handleColorPickerSave, element: element }) })] }), _jsx("div", { className: "flex-1", children: _jsx(Controller, { name: getPropertyName("color"), control: control, render: ({ field }) => (_jsx("input", { type: "text", className: "w-full px-3 py-2 border rounded", value: tempColor || field.value, onChange: (e) => {
                                                                                setTempColor(e.target.value);
                                                                                if (!showColorPicker) {
                                                                                    field.onChange(e.target.value);
                                                                                }
                                                                            } })) }) })] })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Color Opacity" }), _jsx(Controller, { name: getPropertyName("colorOpacity"), control: control, render: ({ field }) => (_jsx(Slider, { min: 0, max: 100, step: 1, value: [
                                                                    typeof field.value === "number" ? field.value : 0,
                                                                ], onValueChange: (value) => field.onChange(value[0]) })) })] })] }) })] })), values.availableSections.background && (_jsxs(AccordionItem, { value: "background", children: [_jsx(AccordionTrigger, { children: "Background" }), _jsx(AccordionContent, { children: _jsx("div", { className: "space-y-4", children: values.elementType === "img" ? (_jsxs(_Fragment, { children: [_jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Image Source URL" }), _jsxs("div", { className: "flex gap-2", children: [_jsx("div", { className: "flex-1", children: _jsx(Controller, { name: "imageSrc", control: control, render: ({ field }) => (_jsx(Input, { type: "text", placeholder: "https://...", ...field, value: String(field.value ?? ""), onChange: (e) => {
                                                                                    field.onChange(e);
                                                                                    setImagePreview(e.target.value);
                                                                                    updateActiveElementStyle({
                                                                                        imageSrc: e.target.value,
                                                                                    });
                                                                                } })) }) }), _jsxs("div", { className: "relative", children: [_jsx("input", { type: "file", id: "image-src-upload", className: "absolute inset-0 w-full h-full opacity-0 cursor-pointer", accept: "image/*", onChange: (e) => handleImageUpload(e, "image"), disabled: isUploading }), _jsx(Button, { type: "button", variant: "outline", className: "h-full", disabled: isUploading, children: isUploading ? (_jsx(FontAwesomeIcon, { icon: faSpinnerThird, className: "h-4 w-4 animate-spin" })) : (_jsx(FontAwesomeIcon, { icon: faUpload, className: "h-4 w-4" })) })] })] })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Alt Text" }), _jsx(Controller, { name: "imageAlt", control: control, render: ({ field }) => (_jsx(Input, { type: "text", placeholder: "Image description for accessibility", ...field, value: field.value || "", onChange: (e) => {
                                                                        field.onChange(e);
                                                                        updateActiveElementStyle({
                                                                            [getPropertyName("imageAlt")]: e.target.value,
                                                                        });
                                                                    } })) })] })] })) : (_jsxs(_Fragment, { children: [_jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Background Color" }), _jsxs("div", { className: "flex items-center gap-2", children: [_jsxs(Popover, { open: showBackgroundPicker, onOpenChange: setShowBackgroundPicker, children: [_jsx(PopoverTrigger, { asChild: true, children: _jsx("div", { className: "w-10 h-10 rounded border cursor-pointer relative", style: {
                                                                                        backgroundColor: tempBackgroundColor ||
                                                                                            getCurrentValue("backgroundColor"),
                                                                                    } }) }), _jsx(PopoverContent, { className: "w-auto p-0", align: "start", id: "codepress-background-color-picker-content", container: shadowRoot, style: { zIndex: 2147483647 }, children: _jsx(ColorPickerContent, { type: "background", color: getCurrentValue("backgroundColor"), tempColor: tempBackgroundColor, onColorChange: (color) => {
                                                                                        setTempBackgroundColor(color);
                                                                                        updateActiveElementStyle({
                                                                                            [getPropertyName("backgroundColor")]: color,
                                                                                        });
                                                                                    }, onClose: () => handleColorPickerCancel("background"), onSave: handleColorPickerSave, element: element }) })] }), _jsx("div", { className: "flex-1", children: _jsx(Controller, { name: getPropertyName("backgroundColor"), control: control, render: ({ field }) => (_jsx("input", { type: "text", className: "w-full px-3 py-2 border rounded", value: tempBackgroundColor ||
                                                                                    field.value, onChange: (e) => {
                                                                                    setTempBackgroundColor(e.target.value);
                                                                                    if (!showBackgroundPicker) {
                                                                                        field.onChange(e.target.value);
                                                                                    }
                                                                                } })) }) })] })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Background Image URL" }), _jsxs("div", { className: "flex gap-2", children: [_jsx("div", { className: "flex-1", children: _jsx(Controller, { name: "backgroundImage", control: control, render: ({ field }) => (_jsx(Input, { type: "text", placeholder: "https://...", ...field, onChange: (e) => {
                                                                                    field.onChange(e);
                                                                                    setImagePreview(e.target.value);
                                                                                } })) }) }), _jsxs("div", { className: "relative", children: [_jsx("input", { type: "file", id: "image-upload", className: "absolute inset-0 w-full h-full opacity-0 cursor-pointer", accept: "image/*", onChange: (e) => handleImageUpload(e, "background"), disabled: isUploading }), _jsx(Button, { type: "button", variant: "outline", className: "h-full", disabled: isUploading, children: isUploading ? (_jsx(FontAwesomeIcon, { icon: faSpinnerThird, className: "h-4 w-4 animate-spin" })) : (_jsx(FontAwesomeIcon, { icon: faUpload, className: "h-4 w-4" })) })] })] })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Background Size" }), _jsx(Controller, { name: "backgroundSize", control: control, render: ({ field }) => (_jsxs(ToggleGroup, { type: "single", value: field.value, onValueChange: field.onChange, className: "justify-start", children: [_jsx(ToggleGroupItem, { value: "cover", children: "Cover" }), _jsx(ToggleGroupItem, { value: "contain", children: "Contain" }), _jsx(ToggleGroupItem, { value: "auto", children: "Auto" })] })) })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Background Position" }), _jsx(Controller, { name: "backgroundPosition", control: control, render: ({ field }) => (_jsxs(ToggleGroup, { type: "single", value: field.value, onValueChange: field.onChange, className: "justify-start", children: [_jsx(ToggleGroupItem, { value: "center", children: "Center" }), _jsx(ToggleGroupItem, { value: "top", children: "Top" }), _jsx(ToggleGroupItem, { value: "bottom", children: "Bottom" })] })) })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Background Repeat" }), _jsx(Controller, { name: "backgroundRepeat", control: control, render: ({ field }) => (_jsxs(ToggleGroup, { type: "single", value: field.value, onValueChange: field.onChange, className: "justify-start", children: [_jsx(ToggleGroupItem, { value: "no-repeat", children: "No Repeat" }), _jsx(ToggleGroupItem, { value: "repeat", children: "Repeat" }), _jsx(ToggleGroupItem, { value: "repeat-x", children: "Repeat X" }), _jsx(ToggleGroupItem, { value: "repeat-y", children: "Repeat Y" })] })) })] })] })) }) })] })), values.availableSections.image && (_jsxs(AccordionItem, { value: "image", children: [_jsx(AccordionTrigger, { children: "Image" }), _jsx(AccordionContent, { children: _jsxs("div", { className: "space-y-4", children: [_jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Image Source URL" }), _jsxs("div", { className: "flex gap-2", children: [_jsx("div", { className: "flex-1", children: _jsx(Controller, { name: "imageSrc", control: control, render: ({ field }) => (_jsx(Input, { type: "text", placeholder: "https://...", ...field, value: field.value || "", onChange: (e) => {
                                                                                field.onChange(e);
                                                                                setImagePreview(e.target.value);
                                                                                updateActiveElementStyle({
                                                                                    imageSrc: e.target.value,
                                                                                });
                                                                            } })) }) }), _jsxs("div", { className: "relative", children: [_jsx("input", { type: "file", id: "image-src-upload", className: "absolute inset-0 w-full h-full opacity-0 cursor-pointer", accept: "image/*", onChange: (e) => handleImageUpload(e, "image"), disabled: isUploading }), _jsx(Button, { type: "button", variant: "outline", className: "h-full", disabled: isUploading, children: isUploading ? (_jsx(FontAwesomeIcon, { icon: faSpinnerThird, className: "h-4 w-4 animate-spin" })) : (_jsx(FontAwesomeIcon, { icon: faUpload, className: "h-4 w-4" })) })] })] })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Alt Text" }), _jsx(Controller, { name: "imageAlt", control: control, render: ({ field }) => (_jsx(Input, { type: "text", placeholder: "Image description for accessibility", ...field, value: field.value || "", onChange: (e) => {
                                                                    field.onChange(e);
                                                                    updateActiveElementStyle({
                                                                        [getPropertyName("imageAlt")]: e.target.value,
                                                                    });
                                                                } })) })] })] }) })] })), values.availableSections.position && (_jsxs(AccordionItem, { value: "position", children: [_jsx(AccordionTrigger, { children: "Position" }), _jsx(AccordionContent, { children: _jsxs("div", { className: "space-y-4", children: [_jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Position" }), _jsx(Controller, { name: "position", control: control, render: ({ field }) => (_jsxs(Select, { value: field.value || "static", onValueChange: field.onChange, children: [_jsx(SelectTrigger, { className: "w-full", children: _jsx(SelectValue, { placeholder: "Select position" }) }), _jsxs(SelectContent, { container: shadowRoot, children: [_jsx(SelectItem, { value: "static", children: "Static" }), _jsx(SelectItem, { value: "relative", children: "Relative" }), _jsx(SelectItem, { value: "absolute", children: "Absolute" }), _jsx(SelectItem, { value: "fixed", children: "Fixed" }), _jsx(SelectItem, { value: "sticky", children: "Sticky" })] })] })) })] }), ["absolute", "fixed", "sticky"].includes(values.position) && (_jsxs(_Fragment, { children: [_jsxs("div", { className: "grid grid-cols-2 gap-4", children: [_jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Left" }), _jsx(Controller, { name: "left", control: control, render: ({ field }) => (_jsx(Input, { type: "text", ...field, value: field.value || "", onChange: (e) => field.onChange(e.target.value) })) })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Top" }), _jsx(Controller, { name: "top", control: control, render: ({ field }) => (_jsx(Input, { type: "text", ...field, value: field.value || "", onChange: (e) => field.onChange(e.target.value) })) })] })] }), _jsxs("div", { className: "grid grid-cols-2 gap-4", children: [_jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Right" }), _jsx(Controller, { name: "right", control: control, render: ({ field }) => (_jsx(Input, { type: "text", ...field, value: field.value || "", onChange: (e) => field.onChange(e.target.value) })) })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Bottom" }), _jsx(Controller, { name: "bottom", control: control, render: ({ field }) => (_jsx(Input, { type: "text", ...field, value: field.value || "", onChange: (e) => field.onChange(e.target.value) })) })] })] })] }))] }) })] })), values.availableSections.transform && (_jsxs(AccordionItem, { value: "transform", children: [_jsx(AccordionTrigger, { children: "Transform" }), _jsx(AccordionContent, { children: _jsx("div", { className: "space-y-4", children: _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Rotation" }), _jsx(Controller, { name: "rotation", control: control, render: ({ field }) => (_jsx(Input, { type: "number", min: "0", max: "360", ...field, value: Number(field.value) || 0 })) })] }) }) })] })), values.availableSections.layout && (_jsxs(AccordionItem, { value: "layout", children: [_jsx(AccordionTrigger, { children: "Layout" }), _jsx(AccordionContent, { children: _jsx("div", { className: "space-y-4", children: _jsxs("div", { className: "grid grid-cols-2 gap-4", children: [_jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Width" }), _jsx(Controller, { name: "width", control: control, render: ({ field }) => (_jsx(Input, { type: "text", ...field, value: field.value || "", onChange: (e) => field.onChange(e.target.value) })) })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Height" }), _jsx(Controller, { name: "height", control: control, render: ({ field }) => (_jsx(Input, { type: "text", ...field, value: field.value || "", onChange: (e) => field.onChange(e.target.value) })) })] })] }) }) })] })), values.availableSections.appearance && (_jsxs(AccordionItem, { value: "appearance", children: [_jsx(AccordionTrigger, { children: "Appearance" }), _jsx(AccordionContent, { children: _jsxs("div", { className: "space-y-4", children: [_jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Opacity" }), _jsx(Controller, { name: "opacity", control: control, render: ({ field }) => (_jsx(Slider, { min: 0, max: 100, step: 1, value: [Number(field.value) || 0], onValueChange: (value) => field.onChange(value[0]) })) })] }), _jsxs("div", { className: "space-y-2", children: [_jsx(Label, { children: "Corner Radius" }), _jsx(Controller, { name: "cornerRadius", control: control, render: ({ field }) => (_jsx(Input, { type: "text", ...field, value: field.value || "", onChange: (e) => field.onChange(e.target.value) })) })] })] }) })] }))] })] }) }) }));
}
