import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import React, { useState, useEffect } from "react";
import { apiFetch, POST_CONFIG } from "../../fetch.js";
import { detectRepositoryInfo } from "../../lib/utils.js";
import { useVisualEditor } from "../../context/VisualEditorContext.js";
import { getCleanElementHTML } from "../../utils/saveChanges.js";
import { API_BASE_URL, BASE_LOCAL_CODEPRESS_DEPRECATED, checkGithubMode, } from "@/lib/env";
import { useDeployment } from "@/context/DeploymentContext";
import { checkIsOnCodepressBranch, sanitizeBranchName, } from "@/lib/deployment";
import { logger } from "@/lib/logger";
import { toast } from "sonner";
import { Send } from "lucide-react";
import BranchSelector from "@/components/saveBar/BranchSelector";
import ShimmerText from "@/components/ui/ShimmerText";
const AgentChatOverlay = ({ onClose }) => {
    const { activeElementFpId, trackedElements } = useVisualEditor();
    const [messages, setMessages] = useState([]);
    const [input, setInput] = useState("");
    const [isSending, setIsSending] = useState(false);
    const [animationsEnabled, setAnimationsEnabled] = useState(true);
    const repoInfo = detectRepositoryInfo();
    // Generate unique message IDs
    const generateMessageId = React.useCallback(() => {
        return `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }, []);
    const { branchName, fetchPreviewData, setShowDeploymentPopover } = useDeployment();
    // Auto-scroll to bottom when new messages are added
    const scrollContainerRef = React.useRef(null);
    const [autoScroll, setAutoScroll] = useState(true);
    const isProgrammaticScrollRef = React.useRef(false);
    const scrollToBottom = React.useCallback(() => {
        const el = scrollContainerRef.current;
        if (!el)
            return;
        // Set flag to indicate programmatic scroll
        isProgrammaticScrollRef.current = true;
        try {
            el.scrollTo({ top: el.scrollHeight, behavior: "smooth" });
        }
        catch {
            el.scrollTop = el.scrollHeight;
            // Clear the flag immediately for instant scroll
            isProgrammaticScrollRef.current = false;
        }
    }, []);
    useEffect(() => {
        if (autoScroll)
            scrollToBottom();
    }, [messages.length, scrollToBottom, autoScroll]);
    useEffect(() => {
        const el = scrollContainerRef.current;
        if (!el)
            return;
        const onScroll = () => {
            const threshold = 8; // px tolerance
            const atBottom = el.scrollHeight - el.scrollTop - el.clientHeight <= threshold;
            // If we're doing programmatic scrolling and have reached the bottom, clear the flag
            if (isProgrammaticScrollRef.current) {
                if (atBottom) {
                    isProgrammaticScrollRef.current = false;
                    setAutoScroll(true); // Ensure autoScroll stays true
                }
                return; // Don't update autoScroll state during programmatic scrolling
            }
            setAutoScroll(atBottom);
        };
        el.addEventListener("scroll", onScroll);
        // Initialize state
        onScroll();
        return () => el.removeEventListener("scroll", onScroll);
    }, []);
    const resumeAutoScroll = React.useCallback(() => {
        setAutoScroll(true);
        scrollToBottom();
    }, [scrollToBottom]);
    // Component to render typing indicator
    const AnimatedEllipsis = () => {
        const [dotCount, setDotCount] = useState(0);
        useEffect(() => {
            const interval = setInterval(() => {
                setDotCount((c) => (c + 1) % 4); // 0-3 dots
            }, 500);
            return () => clearInterval(interval);
        }, []);
        return _jsx("span", { children: ".".repeat(dotCount) });
    };
    // Component to render a single chat message with optional animations
    const ChatMessageItem = ({ message, isActive }) => {
        const { role, content, loading } = message;
        const staticAssistantClass = message.type === "final_result" ? "text-gray-900" : "text-gray-400";
        return (_jsxs("div", { className: "text-gray-900", children: [_jsxs("span", { className: "font-semibold mr-1", children: [role === "user" ? "You" : "Agent", ":"] }), loading ? (_jsx(AnimatedEllipsis, {})) : isActive && role === "assistant" ? (_jsx(ShimmerText, { text: content, disabled: !animationsEnabled, animationDuration: 1.5, windowWidth: 5 })) : (_jsx("span", { className: `whitespace-pre-wrap ${role === "assistant" ? staticAssistantClass : ""}`, children: content }))] }));
    };
    const handleSendStreaming = async (event, ignoreCodepressPrefix = false) => {
        const githubMode = checkGithubMode();
        const instruction = input.trim();
        if (!instruction || !activeElementFpId)
            return;
        // Clear the textarea immediately on submit
        setInput("");
        setIsSending(true);
        // Prepare for a new run: disable until first ephemeral arrives
        setAnimationsEnabled(false);
        // Add user message
        setMessages((prev) => [
            ...prev,
            { id: generateMessageId(), role: "user", content: instruction },
        ]);
        try {
            const newBranchName = sanitizeBranchName(branchName);
            // Use existing endpoint with streaming headers
            const url = githubMode
                ? `${API_BASE_URL}/code-sync/agent-changes-commit`
                : `${BASE_LOCAL_CODEPRESS_DEPRECATED}/visual-editor-api-agent`;
            const body = githubMode
                ? {
                    encoded_location: activeElementFpId,
                    github_repo_name: repoInfo?.repository,
                    user_instruction: instruction,
                    additional_context: {
                        browserWidth: window.innerWidth,
                        browserHeight: window.innerHeight,
                    },
                    githubBaseBranchName: repoInfo?.branch,
                    githubBranchName: newBranchName || repoInfo?.branch,
                }
                : {
                    encoded_location: activeElementFpId,
                    file_content: trackedElements[activeElementFpId]?.originalHtml || "",
                    github_repo_name: repoInfo?.repository,
                    user_instruction: instruction,
                    branch_name: newBranchName || repoInfo?.branch,
                };
            // Use streaming for both GitHub mode and local mode
            const streamingConfig = await POST_CONFIG({
                data: body,
                includeAuth: true,
            });
            streamingConfig.headers = {
                ...streamingConfig.headers,
                Accept: "text/event-stream",
                "Cache-Control": "no-cache",
            };
            const response = await apiFetch(url, streamingConfig);
            if (!response.ok) {
                throw new Error(`Request failed: ${response.status} ${response.statusText}`);
            }
            // Read the streaming response
            const reader = response.body?.getReader();
            const decoder = new TextDecoder();
            console.log("Starting to read streaming response...");
            if (reader) {
                let buffer = "";
                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done)
                            break;
                        buffer += decoder.decode(value, { stream: true });
                        // Process complete SSE events separated by blank lines
                        let sepIndex = buffer.indexOf("\n\n");
                        while (sepIndex !== -1) {
                            const block = buffer.slice(0, sepIndex);
                            buffer = buffer.slice(sepIndex + 2);
                            sepIndex = buffer.indexOf("\n\n");
                            // Aggregate all data: lines within this block
                            const dataLines = [];
                            for (const ln of block.split("\n")) {
                                if (ln.startsWith("data: "))
                                    dataLines.push(ln.slice(6));
                            }
                            if (dataLines.length === 0)
                                continue;
                            const dataStr = dataLines.join("\n");
                            let data;
                            try {
                                data = JSON.parse(dataStr);
                            }
                            catch (e) {
                                console.warn("Skipping malformed SSE data:", dataStr);
                                continue;
                            }
                            if (data.type === "error") {
                                setMessages((prev) => [
                                    ...prev.filter((m) => !m.ephemeral),
                                    {
                                        id: generateMessageId(),
                                        role: "assistant",
                                        content: `‚ùå Error: ${data.error}`,
                                        ephemeral: false,
                                    },
                                ]);
                                return;
                            }
                            if (data.type === "complete") {
                                return;
                            }
                            if (data.type === "tool_end" || data.type === "output_delta") {
                                // Skip showing tool completion messages in UI, but keep streaming
                                continue;
                            }
                            const contentText = data.message || data.content || "";
                            if (data.ephemeral) {
                                if (data.type === "reasoning_delta") {
                                    // Accumulate reasoning into a single growing line
                                    setMessages((prev) => {
                                        const next = [...prev];
                                        let idx = -1;
                                        for (let i = next.length - 1; i >= 0; i--) {
                                            const m = next[i];
                                            if (m.role === "assistant" &&
                                                m.ephemeral &&
                                                m.type === "reasoning") {
                                                idx = i;
                                                break;
                                            }
                                        }
                                        if (idx >= 0) {
                                            next[idx] = {
                                                ...next[idx],
                                                content: (next[idx].content || "") + contentText,
                                            };
                                            return next;
                                        }
                                        return [
                                            ...next,
                                            {
                                                id: generateMessageId(),
                                                role: "assistant",
                                                content: contentText || "",
                                                ephemeral: true,
                                                type: "reasoning",
                                            },
                                        ];
                                    });
                                    // Auto-scroll when reasoning content is updated
                                    if (autoScroll) {
                                        setTimeout(scrollToBottom, 0);
                                    }
                                }
                                else {
                                    // Append other ephemeral events (e.g., tool_start)
                                    setMessages((prev) => [
                                        ...prev,
                                        {
                                            id: generateMessageId(),
                                            role: "assistant",
                                            content: contentText || "Processing...",
                                            ephemeral: true,
                                            type: data.type,
                                        },
                                    ]);
                                }
                                // Enable animation when first ephemeral arrives for this run
                                setAnimationsEnabled(true);
                            }
                            else {
                                // Append final persistent message (do not remove ephemerals)
                                setMessages((prev) => [
                                    ...prev,
                                    {
                                        id: generateMessageId(),
                                        role: "assistant",
                                        content: contentText || `‚úÖ Changes applied successfully!`,
                                        ephemeral: false,
                                        type: data.type,
                                    },
                                ]);
                                if (data.type === "final_result") {
                                    // Stop all animation once final result arrives
                                    setAnimationsEnabled(false);
                                }
                                // Only fetch preview for GitHub mode
                                if (githubMode && data.success) {
                                    const previewData = await fetchPreviewData(newBranchName);
                                    setShowDeploymentPopover(previewData);
                                }
                            }
                        }
                    }
                }
                finally {
                    reader.releaseLock();
                }
            }
        }
        catch (err) {
            // If streaming fails, fallback to non-streaming
            if (err?.message?.includes("streaming") ||
                err?.message?.includes("text/event-stream")) {
                console.warn("Streaming failed, falling back to non-streaming mode");
                try {
                    await handleSend(event, ignoreCodepressPrefix);
                    return;
                }
                catch (fallbackErr) {
                    setMessages((prev) => [
                        ...prev.filter((m) => !m.ephemeral),
                        {
                            id: generateMessageId(),
                            role: "assistant",
                            content: `‚ùå Error: ${fallbackErr?.message || String(fallbackErr)}`,
                            ephemeral: false,
                        },
                    ]);
                }
            }
            else {
                setMessages((prev) => [
                    ...prev.filter((m) => !m.ephemeral),
                    {
                        id: generateMessageId(),
                        role: "assistant",
                        content: `‚ùå Error: ${err?.message || String(err)}`,
                        ephemeral: false,
                    },
                ]);
            }
        }
        finally {
            setIsSending(false);
            setInput("");
        }
    };
    const handleSend = async (event, ignoreCodepressPrefix = false) => {
        const githubMode = checkGithubMode();
        const instruction = input.trim();
        if (!instruction || !activeElementFpId)
            return;
        // Clear the textarea immediately on submit
        setInput("");
        setIsSending(true);
        setAnimationsEnabled(false);
        // Add user message and placeholder assistant loading message
        setMessages((prev) => [
            ...prev,
            { id: generateMessageId(), role: "user", content: instruction },
            {
                id: generateMessageId(),
                role: "assistant",
                content: "",
                loading: true,
            },
        ]);
        try {
            // Use different endpoints based on GitHub mode
            const url = githubMode
                ? `${API_BASE_URL}/code-sync/agent-changes-commit`
                : `${BASE_LOCAL_CODEPRESS_DEPRECATED}/visual-editor-api-agent`;
            const originalHtml = trackedElements[activeElementFpId]?.originalHtml;
            const elementNode = trackedElements[activeElementFpId]?.element;
            const newHtml = elementNode
                ? getCleanElementHTML(elementNode, false)
                : originalHtml;
            let body;
            const newBranchName = sanitizeBranchName(branchName);
            if (newBranchName !== branchName) {
                // TODO: this can be removed at some point if we add hints to the input
                toast.warning("We tweaked your save name", {
                    id: "nameTweak",
                    description: "Invalid characters were removed.",
                });
                logger.log("Your save name has been sanitized");
            }
            if (githubMode) {
                if (!ignoreCodepressPrefix && checkIsOnCodepressBranch(newBranchName)) {
                    toast.warning("Save Confirmation", {
                        id: "saveConfirmation",
                        description: `You are making a change to an agent change on ${newBranchName}`,
                        action: {
                            label: "Confirm",
                            onClick: () => handleSend(event, true),
                        },
                        duration: Infinity,
                    });
                    // TODO: should the save bar consider ai prompt as unsaved changes?
                    setMessages((prev) => prev.map((m, idx) => idx === prev.length - 1
                        ? {
                            ...m,
                            loading: false,
                            content: "Are you sure you want to save on this branch? Please confirm in the toast or switch branches in the save bar below",
                        }
                        : m));
                    return;
                }
                // Use new agent-changes-commit API format
                body = {
                    encoded_location: activeElementFpId,
                    github_repo_name: repoInfo?.repository,
                    user_instruction: instruction,
                    additional_context: {
                        browserWidth: window.innerWidth,
                        browserHeight: window.innerHeight,
                    },
                    githubBaseBranchName: repoInfo?.branch,
                    githubBranchName: newBranchName || repoInfo?.branch,
                };
            }
            else {
                // Use existing visual-editor-api-agent format
                body = {
                    encoded_location: activeElementFpId,
                    file_content: originalHtml || "",
                    github_repo_name: repoInfo?.repository,
                    user_instruction: instruction,
                    branch_name: newBranchName || repoInfo?.branch,
                };
            }
            const res = await apiFetch(url, await POST_CONFIG({ data: body, includeAuth: true }));
            if (!res.ok) {
                // Do not read the body here because apiFetch may have already consumed it
                // when extracting an error message. Rely on status/statusText instead.
                throw new Error(`Request failed: ${res.status} ${res.statusText}`);
            }
            const data = await res.json();
            let agentMsg;
            let consoleMsg = "";
            if (githubMode && data.success) {
                const previewData = await getPreviewLink({ branchName: newBranchName });
                setShowDeploymentPopover({ ...previewData, branch_name: newBranchName });
                // Handle agent-changes-commit response
                agentMsg = `‚úÖ Changes made successfully!\n${data.message}`;
                consoleMsg = `‚úÖ Changes committed successfully!\n${data.message}`;
                if (data.pr_url) {
                    consoleMsg += `\n\nüîó View Pull Request: ${data.pr_url}`;
                }
                if (data.updated_files && data.updated_files.length > 0) {
                    consoleMsg += `\n\nüìù Updated files: ${data.updated_files.join(", ")}`;
                }
            }
            else {
                // Handle local mode or fallback
                agentMsg =
                    data?.message ||
                        "Changes applied locally. Review the result in your editor.";
            }
            logger.log(consoleMsg);
            // Replace the last (loading) assistant message with the actual content
            setMessages((prev) => prev.map((m, idx) => idx === prev.length - 1
                ? { ...m, loading: false, content: agentMsg }
                : m));
            setInput("");
        }
        catch (err) {
            // Enhanced error handling
            let errorMessage = err?.message || String(err);
            if (githubMode) {
                // Parse structured error responses for GitHub mode
                if (errorMessage.includes("Invalid github_repo_name")) {
                    errorMessage = "Please check the repository name format (owner/repo)";
                }
                else if (errorMessage.includes("Repository") &&
                    errorMessage.includes("not found")) {
                    errorMessage =
                        "Repository not found. Please check the repository name and permissions.";
                }
                else if (errorMessage.includes("Invalid encoded location")) {
                    errorMessage = "Invalid file location. Please try again.";
                }
                else if (errorMessage.includes("Agent processing failed")) {
                    errorMessage =
                        "AI processing failed. Please try again or simplify your request.";
                }
                else if (errorMessage.includes("GitHub")) {
                    errorMessage =
                        "GitHub integration error. Please check your permissions.";
                }
            }
            setMessages((prev) => prev.map((m, idx) => idx === prev.length - 1
                ? { ...m, loading: false, content: `‚ùå Error: ${errorMessage}` }
                : m));
        }
        finally {
            setIsSending(false);
        }
    };
    return (_jsxs("div", { onMouseDown: (e) => e.stopPropagation(), className: "relative mt-2 w-[300px] border rounded-md overflow-hidden shadow-lg bg-white flex flex-col max-h-[50vh]", children: [_jsxs("div", { className: "px-3 py-2 bg-gray-50 border-b", children: [_jsxs("div", { className: "flex items-center justify-between mb-2", children: [_jsx("div", { className: "text-sm font-medium", children: "AI Edit" }), _jsx("button", { onClick: onClose, className: "text-xs px-2 py-1 rounded bg-gray-200 hover:bg-gray-300", children: "Close" })] }), _jsxs("div", { className: "flex items-center gap-2", children: [_jsx("span", { className: "text-xs text-gray-600 flex-shrink-0", children: "Save to:" }), _jsx(BranchSelector, {})] })] }), _jsxs("div", { ref: scrollContainerRef, className: "relative flex-1 overflow-auto p-3 space-y-2 text-sm select-text", children: [messages.length === 0 && (_jsx("div", { className: "text-gray-500", children: "Describe the change you want to make to the selected element." })), (() => {
                        const lastEphemeralIndex = (() => {
                            for (let i = messages.length - 1; i >= 0; i--) {
                                if (messages[i]?.ephemeral)
                                    return i;
                            }
                            return -1;
                        })();
                        return messages.map((m, idx) => {
                            const isActive = animationsEnabled &&
                                idx === lastEphemeralIndex &&
                                m.role === "assistant";
                            return (_jsx(ChatMessageItem, { message: m, isActive: isActive }, m.id));
                        });
                    })()] }), !autoScroll && (_jsx("button", { onClick: resumeAutoScroll, className: "absolute right-3 bottom-34 z-10 text-xs px-2 py-1 rounded bg-gray-200 hover:bg-gray-300 text-gray-800 shadow pointer-events-auto", children: "Jump to latest" })), _jsx("div", { className: "p-3 border-t", children: _jsxs("div", { className: "relative flex", children: [_jsx("textarea", { className: "w-full border rounded px-2 py-2 pr-10 text-sm focus:outline-none focus:ring min-h-[100px] resize-none", placeholder: "e.g. Make this button use a green background on hover", value: input, rows: 3, onChange: (e) => setInput(e.target.value), onKeyDown: (e) => {
                                if (e.key === "Enter" && !e.shiftKey) {
                                    e.preventDefault();
                                    handleSendStreaming(e);
                                }
                            } }), _jsx("button", { onClick: handleSendStreaming, disabled: isSending || !input.trim(), "aria-label": "Send message", className: "absolute bottom-2 right-2 h-8 w-8 inline-flex items-center justify-center rounded-md bg-blue-600 text-white disabled:opacity-50 disabled:cursor-not-allowed hover:bg-blue-700", children: _jsx(Send, { size: 16 }) })] }) })] }));
};
export default AgentChatOverlay;
