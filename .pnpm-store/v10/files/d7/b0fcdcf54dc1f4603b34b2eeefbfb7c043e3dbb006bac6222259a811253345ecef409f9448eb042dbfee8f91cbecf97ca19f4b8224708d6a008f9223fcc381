import logger from "../lib/logger.js";
import Sentry from "@/sentry";
export let unsavedStylesCache = {};
// Utility function to convert RGB color to hex if possible
export function rgbToHex(rgb) {
    // Return as-is if it's already hex, named color, or other format
    if (!rgb.startsWith("rgb(") && !rgb.startsWith("rgba(")) {
        return rgb;
    }
    // Extract RGB values from rgb() or rgba() format
    const match = rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)/);
    if (!match) {
        return rgb; // Return original if can't parse
    }
    const r = parseInt(match[1], 10);
    const g = parseInt(match[2], 10);
    const b = parseInt(match[3], 10);
    // Convert to hex
    const toHex = (n) => {
        const hex = n.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
    };
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}
// Function to get computed styles without hover effects
export function getNonHoverComputedStyle(target) {
    logger.debug("[Hover Fix] Getting non-hover computed styles for:", target);
    logger.debug("[Hover Fix] Original element computed styles:", {
        fontSize: window.getComputedStyle(target).fontSize,
        padding: window.getComputedStyle(target).padding,
        backgroundColor: window.getComputedStyle(target).backgroundColor,
    });
    try {
        // Method: Clone element and place it off-screen to avoid hover
        const clone = target.cloneNode(true);
        // Position clone off-screen but still in the document
        clone.style.position = "fixed";
        clone.style.top = "-9999px";
        clone.style.left = "-9999px";
        clone.style.visibility = "hidden";
        clone.style.pointerEvents = "none";
        // Append to body temporarily
        document.body.appendChild(clone);
        // Get computed styles from the clone (which can't be hovered)
        const computed = window.getComputedStyle(clone);
        // Create a copy of the styles since computed styles are live
        const stylesCopy = {};
        for (let i = 0; i < computed.length; i++) {
            const prop = computed[i];
            stylesCopy[prop] = computed.getPropertyValue(prop);
        }
        // Remove the clone
        document.body.removeChild(clone);
        logger.debug("[Hover Fix] Successfully got non-hover styles using clone method");
        logger.debug("[Hover Fix] Clone computed styles:", {
            fontSize: computed.fontSize,
            padding: computed.padding,
            backgroundColor: computed.backgroundColor,
        });
        logger.debug("[Hover Fix] Copied styles sample:", {
            fontSize: stylesCopy.fontSize || stylesCopy["font-size"],
            padding: stylesCopy.padding,
            backgroundColor: stylesCopy.backgroundColor || stylesCopy["background-color"],
        });
        // Return a proxy that mimics CSSStyleDeclaration
        return new Proxy(stylesCopy, {
            get(target, prop) {
                if (prop === "getPropertyValue") {
                    return (property) => target[property] || "";
                }
                return target[prop];
            },
        });
    }
    catch (error) {
        Sentry.captureException(error);
        console.warn("[Hover Fix] Failed to get non-hover styles using clone, using regular computed style:", error);
        return window.getComputedStyle(target);
    }
}
export function getElementValues(target) {
    // Use regular computed styles for most properties
    const computed = window.getComputedStyle(target);
    // Use clone method only for background color to avoid hover state
    const nonHoverComputed = getNonHoverComputedStyle(target);
    // Helper function to parse CSS value and unit
    const parseCssValue = (value) => {
        const num = parseFloat(value);
        const unit = value.match(/[a-z%]+$/)?.[0] || "";
        return { num: isNaN(num) ? 0 : num, unit };
    };
    // ------------------------------------------------------------------
    // Helpers to determine whether a property value is implicitly the UA
    // default (i.e. not authored). We only blank defaults – authored values
    // like padding:0 or border:none should be kept and displayed.
    // ------------------------------------------------------------------
    // Simple cache so we only create one dummy element per tag name
    const defaultCache = {};
    const getDefaultComputed = (tag) => {
        if (!defaultCache[tag]) {
            const dummy = document.createElement(tag);
            document.body.appendChild(dummy);
            defaultCache[tag] = window.getComputedStyle(dummy);
            document.body.removeChild(dummy);
        }
        return defaultCache[tag];
    };
    const isAuthored = (cssProp) => {
        // 1. Inline style present
        if (target.style.getPropertyValue(cssProp))
            return true;
        // 2. Check if computed differs from UA default – if so, some stylesheet authored it
        const tag = target.tagName.toLowerCase();
        const defaultVal = getDefaultComputed(tag).getPropertyValue(cssProp).trim();
        const currentVal = computed.getPropertyValue(cssProp).trim();
        return currentVal !== defaultVal;
    };
    const blankIfZero = (cssProp) => {
        const value = computed.getPropertyValue(cssProp);
        if (!value)
            return "";
        const trimmed = value.trim();
        // If property is authored, respect whatever value it is (even "0px")
        if (isAuthored(cssProp))
            return trimmed;
        // Otherwise, blank out common zero defaults
        if (/^0([a-z%]+)?$/i.test(trimmed))
            return "";
        if (/^(0([a-z%]+)?\s+){3}0([a-z%]+)?$/i.test(trimmed))
            return "";
        return trimmed;
    };
    const blankIfNoBorder = (cssProp) => {
        const value = computed.getPropertyValue(cssProp);
        if (!value)
            return "";
        // Keep if authored
        if (isAuthored(cssProp))
            return value.trim();
        const trimmed = value.trim().toLowerCase();
        if (trimmed === "none")
            return "";
        if (trimmed.startsWith("0") && trimmed.includes("none"))
            return "";
        if (trimmed.startsWith("0"))
            return "";
        return value;
    };
    // Helper to get individual or shorthand spacing
    const getSpacing = (prop) => blankIfZero(prop);
    // Helper to get border values
    const getBorder = (prop) => blankIfNoBorder(prop);
    // Helper to get corner radius values
    const getRadius = (prop) => blankIfZero(prop);
    // Helper to get authored CSS values by searching through applied CSS rules
    const getAuthoredValue = (cssProperty) => {
        try {
            // First check inline styles
            const inlineValue = target.style.getPropertyValue(cssProperty);
            if (inlineValue) {
                console.log(`Found inline ${cssProperty}:`, inlineValue);
                return inlineValue;
            }
            // Then search through stylesheets for matching rules
            const stylesheets = Array.from(document.styleSheets);
            console.log(`Searching ${stylesheets.length} stylesheets for ${cssProperty}`);
            let foundRules = [];
            for (const stylesheet of stylesheets) {
                try {
                    const rules = stylesheet.cssRules || stylesheet.rules;
                    if (!rules)
                        continue;
                    for (const rule of Array.from(rules)) {
                        if (rule instanceof CSSStyleRule) {
                            // Check if this rule matches our element
                            try {
                                if (target.matches(rule.selectorText)) {
                                    const ruleValue = rule.style.getPropertyValue(cssProperty);
                                    if (ruleValue) {
                                        foundRules.push({
                                            selector: rule.selectorText,
                                            value: ruleValue,
                                            stylesheet: stylesheet.href || "inline",
                                        });
                                        console.log(`Found matching rule: ${rule.selectorText} -> ${cssProperty}: ${ruleValue}`);
                                    }
                                }
                            }
                            catch (e) {
                                // Skip invalid selectors
                                continue;
                            }
                        }
                    }
                }
                catch (e) {
                    // Skip stylesheets that can't be accessed (CORS)
                    console.log(`Skipped stylesheet due to CORS:`, stylesheet.href);
                    continue;
                }
            }
            console.log(`Found ${foundRules.length} matching rules for ${cssProperty}:`, foundRules);
            // Return the last matching rule (highest specificity/precedence)
            if (foundRules.length > 0) {
                return foundRules[foundRules.length - 1].value;
            }
        }
        catch (e) {
            console.warn(`Error getting authored value for ${cssProperty}:`, e);
        }
        // Fallback to computed value
        const computedValue = window.getComputedStyle(target).getPropertyValue(cssProperty) || "";
        console.log(`Fallback to computed ${cssProperty}:`, computedValue);
        return computedValue;
    };
    // Helper to get color (handle 'rgba(0, 0, 0, 0)' as empty and convert RGB to hex)
    // Use non-hover computed styles for colors to avoid hover state
    const getColor = (prop) => {
        const color = nonHoverComputed.getPropertyValue(prop);
        if (color === "rgba(0, 0, 0, 0)") {
            return "";
        }
        return rgbToHex(color);
    };
    // Debug the computed styles we're using
    logger.debug("[Debug] Regular computed styles (for typography/spacing):", {
        fontSize: computed.fontSize,
        padding: computed.getPropertyValue("padding"),
        fontFamily: computed.fontFamily,
    });
    logger.debug("[Debug] Non-hover computed styles (for colors):", {
        backgroundColor: nonHoverComputed.getPropertyValue("background-color"),
        color: nonHoverComputed.getPropertyValue("color"),
    });
    // You can expand this to extract more values from the element as needed
    const result = {
        element: target,
        elementType: target.tagName.toLowerCase(),
        availableSections: {
            position: true, // Enable based on computed position? (static/relative/absolute/fixed)
            transform: true,
            layout: true,
            appearance: true,
            typography: true, // Always relevant for most elements
            background: true,
            color: true,
            image: target.tagName.toLowerCase() === "img",
        },
        position: computed.position,
        left: computed.left,
        top: computed.top,
        right: computed.right,
        bottom: computed.bottom,
        width: computed.width,
        height: computed.height,
        padding: getSpacing("padding"),
        paddingTop: getSpacing("padding-top"),
        paddingRight: getSpacing("padding-right"),
        paddingBottom: getSpacing("padding-bottom"),
        paddingLeft: getSpacing("padding-left"),
        margin: getSpacing("margin"),
        marginTop: getSpacing("margin-top"),
        marginRight: getSpacing("margin-right"),
        marginBottom: getSpacing("margin-bottom"),
        marginLeft: getSpacing("margin-left"),
        showAdvancedSpacing: false, // Default, user can toggle
        rotation: 0,
        opacity: parseFloat(computed.opacity) * 100,
        borderTop: getBorder("border-top"),
        borderRight: getBorder("border-right"),
        borderBottom: getBorder("border-bottom"),
        borderLeft: getBorder("border-left"),
        cornerRadius: getRadius("border-radius"),
        borderTopLeftRadius: getRadius("border-top-left-radius"),
        borderTopRightRadius: getRadius("border-top-right-radius"),
        borderBottomRightRadius: getRadius("border-bottom-right-radius"),
        borderBottomLeftRadius: getRadius("border-bottom-left-radius"),
        fontSize: computed.fontSize,
        lineHeight: computed.lineHeight,
        letterSpacing: computed.letterSpacing,
        fontFamily: computed.fontFamily,
        textAlign: computed.textAlign,
        fontWeight: computed.fontWeight,
        fontStyle: computed.fontStyle,
        textDecoration: computed.textDecoration,
        backgroundColor: getColor("background-color"),
        backgroundImage: computed.backgroundImage,
        backgroundSize: computed.backgroundSize,
        backgroundPosition: computed.backgroundPosition,
        backgroundRepeat: computed.backgroundRepeat,
        imageSrc: target.tagName.toLowerCase() === "img"
            ? target.src
            : "",
        imageAlt: target.tagName.toLowerCase() === "img"
            ? target.alt
            : "",
        color: getColor("color"),
        colorOpacity: 100,
        text: target.innerText || target.textContent || "",
        href: target.tagName.toLowerCase() === "a"
            ? target.href
            : "",
        // Layout properties
        display: computed.display,
        flexDirection: computed.flexDirection,
        flexWrap: computed.flexWrap,
        justifyContent: computed.justifyContent,
        alignItems: computed.alignItems,
        alignContent: computed.alignContent,
        justifyItems: computed.getPropertyValue("justify-items") || "",
        order: computed.order,
        alignSelf: computed.alignSelf,
        gridTemplateColumns: getAuthoredValue("grid-template-columns"),
        gridTemplateRows: getAuthoredValue("grid-template-rows"),
        gap: computed.gap,
        rowGap: computed.rowGap,
        columnGap: computed.columnGap,
        gridColumn: computed.gridColumn,
        gridRow: computed.gridRow,
        overflow: computed.overflow,
        overflowX: computed.overflowX,
        overflowY: computed.overflowY,
        // Extract hover styles from CSS rules
        ...extractHoverValues(target),
    };
    logger.debug("[Debug] Final FormValues result:", {
        fontSize: result.fontSize,
        padding: result.padding,
        backgroundColor: result.backgroundColor,
        fontFamily: result.fontFamily,
    });
    return result;
}
// Function to extract hover styles from Tailwind classes
export function getTailwindHoverStyles(target) {
    const hoverStyles = {};
    const classes = Array.from(target.classList);
    logger.debug("[Hover Debug] Parsing Tailwind classes:", classes);
    for (const className of classes) {
        if (className.startsWith("hover:")) {
            const hoverClass = className.substring(6); // Remove 'hover:' prefix
            logger.debug(`[Hover Debug] Found Tailwind hover class: ${className} -> ${hoverClass}`);
            // Parse common Tailwind patterns
            if (hoverClass.startsWith("bg-[") && hoverClass.endsWith("]")) {
                // hover:bg-[#f5a623] -> background-color: #f5a623
                const color = hoverClass.slice(3, -1); // Remove 'bg-[' and ']'
                hoverStyles["background-color"] = color;
                logger.debug(`[Hover Debug] Extracted background-color: ${color}`);
            }
            else if (hoverClass.startsWith("text-[") && hoverClass.endsWith("]")) {
                // hover:text-[#ffffff] -> color: #ffffff
                const color = hoverClass.slice(5, -1); // Remove 'text-[' and ']'
                hoverStyles["color"] = color;
                logger.debug(`[Hover Debug] Extracted color: ${color}`);
            }
            else if (hoverClass.startsWith("bg-")) {
                // hover:bg-red-500 -> need to resolve Tailwind color
                const tailwindColor = resolveTailwindColor(hoverClass);
                if (tailwindColor) {
                    hoverStyles["background-color"] = tailwindColor;
                    logger.debug(`[Hover Debug] Extracted Tailwind bg color: ${tailwindColor}`);
                }
            }
            else if (hoverClass.startsWith("text-")) {
                // hover:text-red-500 -> need to resolve Tailwind color
                const tailwindColor = resolveTailwindColor(hoverClass.replace("text-", "bg-"));
                if (tailwindColor) {
                    hoverStyles["color"] = tailwindColor;
                    logger.debug(`[Hover Debug] Extracted Tailwind text color: ${tailwindColor}`);
                }
            }
            // Add more Tailwind patterns as needed (font-size, opacity, etc.)
        }
    }
    return hoverStyles;
}
// Helper to resolve Tailwind color names to hex values
export function resolveTailwindColor(className) {
    // This is a simplified version - in reality, you'd need the full Tailwind color palette
    const colorMap = {
        "bg-red-500": "#ef4444",
        "bg-blue-500": "#3b82f6",
        "bg-green-500": "#22c55e",
        "bg-yellow-500": "#eab308",
        "bg-purple-500": "#a855f7",
        "bg-pink-500": "#ec4899",
        "bg-indigo-500": "#6366f1",
        "bg-gray-500": "#6b7280",
        // Add more as needed
    };
    return colorMap[className] || null;
}
// Function to extract hover styles from CSS rules
export function getHoverStyles(target) {
    // First try to get styles from Tailwind classes
    const tailwindStyles = getTailwindHoverStyles(target);
    logger.debug("[Hover Debug] Tailwind hover styles:", tailwindStyles);
    // Then get styles from CSS rules
    const cssStyles = getCSSHoverStyles(target);
    logger.debug("[Hover Debug] CSS hover styles:", cssStyles);
    // Merge both (CSS rules take precedence over Tailwind)
    const mergedStyles = { ...tailwindStyles, ...cssStyles };
    // Final cleanup pass on merged styles
    const cleanedStyles = { ...mergedStyles };
    for (const [property, value] of Object.entries(cleanedStyles)) {
        if ((property === "background-color" || property === "color") &&
            typeof value === "string") {
            let cleanValue = value;
            if (cleanValue.startsWith("[")) {
                cleanValue = cleanValue.substring(1);
            }
            if (cleanValue.endsWith("]")) {
                cleanValue = cleanValue.slice(0, -1);
            }
            if (cleanValue !== value) {
                logger.debug(`[Hover Debug] Final cleanup ${property}: ${value} -> ${cleanValue}`);
                cleanedStyles[property] = cleanValue;
            }
        }
    }
    logger.debug("[Hover Debug] Merged styles (after cleaning):", cleanedStyles);
    return cleanedStyles;
}
// Function to extract hover styles from CSS rules (renamed from getHoverStyles)
export function getCSSHoverStyles(target) {
    const hoverStyles = {};
    const fpId = target.getAttribute("codepress-data-fp");
    logger.debug("[Hover Debug] Starting hover style extraction for element:", target);
    logger.debug("[Hover Debug] Element fpId:", fpId);
    logger.debug("[Hover Debug] Element classes:", Array.from(target.classList));
    logger.debug("[Hover Debug] Element tag:", target.tagName.toLowerCase());
    try {
        // Get all stylesheets
        const stylesheets = Array.from(document.styleSheets);
        logger.debug("[Hover Debug] Found stylesheets:", stylesheets.length);
        for (let i = 0; i < stylesheets.length; i++) {
            const stylesheet = stylesheets[i];
            logger.debug(`[Hover Debug] Processing stylesheet ${i}:`, stylesheet.href || "inline");
            try {
                // Access CSS rules (might fail due to CORS)
                const rules = stylesheet.cssRules || stylesheet.rules;
                if (!rules) {
                    logger.debug(`[Hover Debug] No rules in stylesheet ${i}`);
                    continue;
                }
                logger.debug(`[Hover Debug] Stylesheet ${i} has ${rules.length} rules`);
                for (let j = 0; j < rules.length; j++) {
                    const rule = rules[j];
                    if (rule instanceof CSSStyleRule) {
                        const selectorText = rule.selectorText;
                        // Check if this rule matches our element with :hover
                        if (selectorText.includes(":hover")) {
                            logger.debug("[Hover Debug] Found hover rule:", selectorText);
                            const isMatch = checkSelectorMatch(target, selectorText, fpId);
                            logger.debug("[Hover Debug] Rule matches?", isMatch);
                            if (isMatch) {
                                logger.debug("[Hover Debug] MATCH! Extracting styles from:", selectorText);
                                // Extract styles from this hover rule
                                const style = rule.style;
                                for (let k = 0; k < style.length; k++) {
                                    const property = style[k];
                                    const value = style.getPropertyValue(property);
                                    if (value) {
                                        logger.debug(`[Hover Debug] Found property: ${property} = ${value}`);
                                        // Clean up malformed CSS values (e.g., [#f5a623 -> #f5a623)
                                        let cleanValue = value;
                                        if (property === "background-color" ||
                                            property === "color") {
                                            // Remove leading [ if present
                                            if (cleanValue.startsWith("[")) {
                                                cleanValue = cleanValue.substring(1);
                                            }
                                            // Remove trailing ] if present
                                            if (cleanValue.endsWith("]")) {
                                                cleanValue = cleanValue.slice(0, -1);
                                            }
                                            logger.debug(`[Hover Debug] Cleaned ${property}: ${value} -> ${cleanValue}`);
                                        }
                                        hoverStyles[property] = cleanValue;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (e) {
                Sentry.captureException(e);
                // Skip stylesheets that can't be accessed (CORS)
                console.warn(`[Hover Debug] Could not access stylesheet ${i}:`, e);
            }
        }
    }
    catch (e) {
        Sentry.captureException(e);
        console.warn("[Hover Debug] Error extracting hover styles:", e);
    }
    return hoverStyles;
}
// Helper function to check if a CSS selector matches our element
export function checkSelectorMatch(element, selectorText, fpId) {
    try {
        // Remove :hover from selector for matching
        const baseSelector = selectorText.replace(/:hover/g, "").trim();
        // Check CodePress data attribute patterns
        if (fpId && selectorText.includes(`[codepress-data-fp="${fpId}"]`)) {
            return true;
        }
        // Try direct element.matches with base selector first
        if (element.matches && baseSelector) {
            try {
                const matches = element.matches(baseSelector);
                if (matches) {
                    return true;
                }
            }
            catch (e) {
                Sentry.captureException(e);
            }
        }
        // Special handling for Tailwind CSS patterns
        // Tailwind generates complex selectors like .hover\:bg-\[\#f5a623\]:hover
        const classes = Array.from(element.classList);
        // Check if element has hover-related classes that match the selector
        for (const className of classes) {
            // Handle Tailwind hover classes (e.g., hover:bg-[#f5a623])
            if (className.startsWith("hover:")) {
                // Convert class name to CSS selector pattern
                // hover:bg-[#f5a623] becomes .hover\:bg-\[\#f5a623\]:hover
                const escapedClassName = className.replace(/[\[\]#:]/g, "\\$&");
                const tailwindSelector = `.${escapedClassName}:hover`;
                if (selectorText.includes(escapedClassName) ||
                    selectorText.includes(className)) {
                    return true;
                }
            }
            // Regular class matching
            const classSelector = `.${className}:hover`;
            if (selectorText.includes(classSelector) ||
                selectorText === classSelector) {
                return true;
            }
        }
        // Check tag-based selectors
        const tagName = element.tagName.toLowerCase();
        const tagSelector = `${tagName}:hover`;
        if (selectorText.includes(tagSelector) || selectorText === tagSelector) {
            return true;
        }
        // Check ID-based selectors
        if (element.id) {
            const idSelector = `#${element.id}:hover`;
            if (selectorText.includes(idSelector) || selectorText === idSelector) {
                return true;
            }
        }
        return false;
    }
    catch (e) {
        Sentry.captureException(e);
        return false;
    }
}
// Function to convert CSS hover styles to FormValues format
export function extractHoverValues(target) {
    const hoverStyles = getHoverStyles(target);
    const hoverValues = {
        hover_backgroundColor: "",
        hover_color: "",
        hover_colorOpacity: 100,
        hover_fontSize: "",
        hover_opacity: 100,
        hover_cornerRadius: "",
        hover_padding: "",
        hover_paddingTop: "",
        hover_paddingRight: "",
        hover_paddingBottom: "",
        hover_paddingLeft: "",
        hover_margin: "",
        hover_marginTop: "",
        hover_marginRight: "",
        hover_marginBottom: "",
        hover_marginLeft: "",
        hover_width: "",
        hover_height: "",
        hover_lineHeight: "",
        hover_letterSpacing: "",
        hover_textAlign: "left",
    };
    // Map CSS properties to our hover form fields
    const propertyMap = {
        "background-color": "hover_backgroundColor",
        color: "hover_color",
        "font-size": "hover_fontSize",
        opacity: "hover_opacity",
        "border-radius": "hover_cornerRadius",
        padding: "hover_padding",
        "padding-top": "hover_paddingTop",
        "padding-right": "hover_paddingRight",
        "padding-bottom": "hover_paddingBottom",
        "padding-left": "hover_paddingLeft",
        margin: "hover_margin",
        "margin-top": "hover_marginTop",
        "margin-right": "hover_marginRight",
        "margin-bottom": "hover_marginBottom",
        "margin-left": "hover_marginLeft",
        width: "hover_width",
        height: "hover_height",
        "line-height": "hover_lineHeight",
        "letter-spacing": "hover_letterSpacing",
        "text-align": "hover_textAlign",
    };
    // Convert found hover styles to form values
    for (const [cssProp, value] of Object.entries(hoverStyles)) {
        const formField = propertyMap[cssProp];
        if (formField && value) {
            if (formField === "hover_opacity") {
                // Convert opacity from 0-1 to 0-100
                hoverValues.hover_opacity = Math.round(parseFloat(value) * 100);
            }
            else if (formField === "hover_colorOpacity") {
                hoverValues.hover_colorOpacity = Math.round(parseFloat(value) * 100);
            }
            else if (formField in hoverValues) {
                // Type-safe assignment
                hoverValues[formField] = value;
            }
        }
    }
    logger.debug("[Hover Debug] Final extracted hover values:", hoverValues);
    return hoverValues;
}
// NEW: Helper to apply style updates to a target element
export function applyStylesToTarget(target, updates, isCommitted = false // New flag to indicate if this is a final state
) {
    if (!target)
        return;
    logger.debug("[ContentScript] applyStylesToTarget: Target:", target, "Updates:", JSON.parse(JSON.stringify(updates))); // LOGGING
    const fpId = target.getAttribute("codepress-data-fp");
    // If this is a committed save, remove all inline styles to revert to CSS classes
    // if (isCommitted) {
    //   logger.debug(
    //     "[ContentScript] Committed save - removing inline styles for changed properties only"
    //   );
    //   // Only remove the inline styles for properties that were actually changed
    //   Object.keys(updates).forEach((key) => {
    //     const cssProperty = key.replace(/([A-Z])/g, "-$1").toLowerCase();
    //     // Skip non-CSS properties like imageSrc, imageAlt, showAdvancedSpacing, etc.
    //     if (
    //       key === "imageSrc" ||
    //       key === "imageAlt" ||
    //       key === "showAdvancedSpacing" ||
    //       key === "elementType" ||
    //       key === "availableSections" ||
    //       key === "element"
    //     ) {
    //       return;
    //     }
    //     // Remove the specific CSS property that was changed
    //     target.style.removeProperty(cssProperty);
    //     logger.debug(`[ContentScript] Removed inline style: ${cssProperty}`);
    //   });
    //   // Clear the cache since changes are now committed
    //   if (fpId) {
    //     delete unsavedStylesCache[fpId];
    //   }
    //   return; // Exit early for committed saves
    // }
    const pseudoState = updates._pseudoState || (updates._isHoverState ? "hover" : null);
    const baseProperty = updates._baseProperty;
    // Create a unique ID for this element to track pseudo-state styles
    const elementId = target.getAttribute("codepress-data-fp") || target.tagName + Math.random();
    if (pseudoState && baseProperty) {
        // Handle pseudo-state (hover / active) updates
        const value = updates[baseProperty];
        // Create or update the style element for this pseudo state
        let styleElement = document.getElementById(`codepress-${pseudoState}-${elementId}`);
        if (!styleElement) {
            styleElement = document.createElement("style");
            styleElement.id = `codepress-${pseudoState}-${elementId}`;
            document.head.appendChild(styleElement);
        }
        let cssProperty = propertyAliasMap[baseProperty] ??
            baseProperty.replace(/([A-Z])/g, "-$1").toLowerCase();
        let cssValue = String(value);
        // Handle special properties
        if (baseProperty === "rotation") {
            cssValue = `rotate(${value}deg)`;
            cssProperty = "transform";
        }
        else if (baseProperty === "opacity") {
            cssValue = String(parseFloat(String(value)) / 100);
        }
        else if (baseProperty === "fontSize" && /^\d+(\.\d+)?$/.test(cssValue)) {
            cssValue = `${cssValue}px`;
        }
        else if (baseProperty === "colorOpacity") {
            // Handle pseudo-state updates for color opacity by generating an rgba color value
            // Determine the base color using the same precedence as the normal state handler
            let baseColor = undefined;
            // 1. Prefer the color included in this batch of updates
            if (typeof updates.color === "string" && updates.color) {
                baseColor = updates.color;
            }
            // 2. Fall back to any previously cached unsaved color for this element
            else if (fpId && unsavedStylesCache[fpId]?.color) {
                baseColor = String(unsavedStylesCache[fpId].color);
            }
            // 3. Finally fall back to the element's currently computed color
            else {
                baseColor = window.getComputedStyle(target).getPropertyValue("color");
            }
            // Helper to convert hex or rgb(a) → rgba with the desired opacity
            const toRgba = (color, alpha) => {
                color = color.trim();
                // Hex (e.g. #ffffff or #fff)
                if (color.startsWith("#")) {
                    let r, g, b;
                    if (color.length === 4) {
                        // Short hex (#fff)
                        r = parseInt(color[1] + color[1], 16);
                        g = parseInt(color[2] + color[2], 16);
                        b = parseInt(color[3] + color[3], 16);
                    }
                    else {
                        // Full hex (#ffffff)
                        r = parseInt(color.slice(1, 3), 16);
                        g = parseInt(color.slice(3, 5), 16);
                        b = parseInt(color.slice(5, 7), 16);
                    }
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }
                // rgb / rgba
                const rgbMatch = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)/);
                if (rgbMatch) {
                    const r = parseInt(rgbMatch[1], 10);
                    const g = parseInt(rgbMatch[2], 10);
                    const b = parseInt(rgbMatch[3], 10);
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }
                // Fallback for named colors or unexpected formats – let the browser resolve it first
                const temp = document.createElement("div");
                temp.style.color = color;
                document.body.appendChild(temp);
                const computed = window.getComputedStyle(temp).color;
                document.body.removeChild(temp);
                return toRgba(computed, alpha);
            };
            const alpha = parseFloat(String(value)) / 100;
            const rgbaColor = toRgba(baseColor || "rgb(0,0,0)", alpha);
            cssProperty = "color";
            cssValue = rgbaColor;
        }
        // Create the hover CSS rule
        const selector = `[codepress-data-fp="${elementId}"]:${pseudoState}`;
        styleElement.textContent = `${selector} { ${cssProperty}: ${cssValue} !important; }`;
        return;
    }
    // For non-committed updates (live preview), apply styles as before
    Object.entries(updates).forEach(([key, value]) => {
        // Skip internal properties
        if (key.startsWith("_"))
            return;
        const cssProperty = propertyAliasMap[key] ?? key.replace(/([A-Z])/g, "-$1").toLowerCase();
        if (value === null || value === undefined || value === "") {
            if (key === "imageSrc" && target.tagName === "IMG") {
                target.removeAttribute("src");
            }
            else if (key === "imageAlt" && target.tagName === "IMG") {
                target.removeAttribute("alt");
            }
            else {
                target.style.removeProperty(cssProperty); // Remove style if value is empty/null/undefined
            }
            return;
        }
        // Special handling for properties
        if (key === "rotation") {
            target.style.transform =
                target.style.transform.replace(/rotate\([^)]*\)/, "") +
                    ` rotate(${value}deg)`;
        }
        else if (key === "opacity") {
            target.style.opacity = String(parseFloat(String(value)) / 100);
        }
        else if (key === "fontSize") {
            const strValue = String(value);
            if (/^\d+(\.\d+)?$/.test(strValue)) {
                // Check if it's a number (integer or float)
                target.style.setProperty(cssProperty, `${strValue}px`);
            }
            else {
                target.style.setProperty(cssProperty, strValue); // Use as is if it already has a unit or other format
            }
        }
        else if (key === "colorOpacity") {
            // Special handling for color opacity even when the base color isn't part of this update
            let baseColor = undefined;
            // 1. Prefer the color included in this batch of updates
            if (typeof updates.color === "string" && updates.color) {
                baseColor = updates.color;
            }
            // 2. Fall back to any previously cached unsaved color for this element
            else if (fpId && unsavedStylesCache[fpId]?.color) {
                baseColor = String(unsavedStylesCache[fpId].color);
            }
            // 3. Finally fall back to the element's currently computed color
            else {
                baseColor = window.getComputedStyle(target).getPropertyValue("color");
            }
            // Helper to convert hex or rgb(a) → rgba with the desired opacity
            const toRgba = (color, alpha) => {
                color = color.trim();
                // Hex (e.g. #ffffff or #fff)
                if (color.startsWith("#")) {
                    let r, g, b;
                    if (color.length === 4) {
                        // Short hex (#fff)
                        r = parseInt(color[1] + color[1], 16);
                        g = parseInt(color[2] + color[2], 16);
                        b = parseInt(color[3] + color[3], 16);
                    }
                    else {
                        // Full hex (#ffffff)
                        r = parseInt(color.slice(1, 3), 16);
                        g = parseInt(color.slice(3, 5), 16);
                        b = parseInt(color.slice(5, 7), 16);
                    }
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }
                // rgb / rgba
                const rgbMatch = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)/);
                if (rgbMatch) {
                    const r = parseInt(rgbMatch[1], 10);
                    const g = parseInt(rgbMatch[2], 10);
                    const b = parseInt(rgbMatch[3], 10);
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }
                // Fallback for named colors or unexpected formats – let the browser resolve it first
                const temp = document.createElement("div");
                temp.style.color = color;
                document.body.appendChild(temp);
                const computed = window.getComputedStyle(temp).color;
                document.body.removeChild(temp);
                return toRgba(computed, alpha);
            };
            const alpha = parseFloat(String(value)) / 100;
            const rgbaColor = toRgba(baseColor || "rgb(0,0,0)", alpha);
            target.style.setProperty("color", rgbaColor);
        }
        else if (key === "imageSrc" && target.tagName === "IMG") {
            target.src = String(value);
            target.removeAttribute("srcset"); // Remove srcset to ensure src is used
        }
        else if (key === "imageAlt" && target.tagName === "IMG") {
            target.alt = String(value);
        }
        else {
            logger.debug("cssProperty", cssProperty);
            target.style.setProperty(cssProperty, String(value));
        }
    });
    // Update or clear the cache
    if (fpId) {
        // Ensure fpId is not null
        if (Object.keys(updates).length > 0) {
            // Only cache if there are actual updates
            // logger.debug("Updating unsavedStylesCache for fpId:", fpId, "with updates:", updates);
            unsavedStylesCache[fpId] = {
                ...(unsavedStylesCache[fpId] || {}),
                ...updates,
            };
        }
        // logger.debug("Current unsavedStylesCache:", JSON.parse(JSON.stringify(unsavedStylesCache)));
    }
}
// Map non-standard form keys to actual CSS properties
const propertyAliasMap = {
    // appearance
    cornerRadius: "border-radius",
    // rotation is handled separately (mapped to transform) so no alias here
};
