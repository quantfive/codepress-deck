import { WINDOW as l, wrap as p } from "./index116.js";
import { defineIntegration as m } from "./index144.js";
import { fill as s, getOriginalFunction as h } from "./index119.js";
import { getFunctionName as c } from "./index131.js";
const E = [
  "EventTarget",
  "Window",
  "Node",
  "ApplicationCache",
  "AudioTrackList",
  "BroadcastChannel",
  "ChannelMergerNode",
  "CryptoOperation",
  "EventSource",
  "FileReader",
  "HTMLUnknownElement",
  "IDBDatabase",
  "IDBRequest",
  "IDBTransaction",
  "KeyOperation",
  "MediaController",
  "MessagePort",
  "ModalWindow",
  "Notification",
  "SVGElementInstance",
  "Screen",
  "SharedWorker",
  "TextTrack",
  "TextTrackCue",
  "TextTrackList",
  "WebSocket",
  "WebSocketWorker",
  "Worker",
  "XMLHttpRequest",
  "XMLHttpRequestEventTarget",
  "XMLHttpRequestUpload"
], T = "BrowserApiErrors", v = (e = {}) => {
  const t = {
    XMLHttpRequest: !0,
    eventTarget: !0,
    requestAnimationFrame: !0,
    setInterval: !0,
    setTimeout: !0,
    unregisterOriginalCallbacks: !1,
    ...e
  };
  return {
    name: T,
    // TODO: This currently only works for the first client this is setup
    // We may want to adjust this to check for client etc.
    setupOnce() {
      t.setTimeout && s(l, "setTimeout", f), t.setInterval && s(l, "setInterval", f), t.requestAnimationFrame && s(l, "requestAnimationFrame", y), t.XMLHttpRequest && "XMLHttpRequest" in l && s(XMLHttpRequest.prototype, "send", L);
      const r = t.eventTarget;
      r && (Array.isArray(r) ? r : E).forEach((a) => g(a, t));
    }
  };
}, R = m(v);
function f(e) {
  return function(...t) {
    const r = t[0];
    return t[0] = p(r, {
      mechanism: {
        data: { function: c(e) },
        handled: !1,
        type: "instrument"
      }
    }), e.apply(this, t);
  };
}
function y(e) {
  return function(t) {
    return e.apply(this, [
      p(t, {
        mechanism: {
          data: {
            function: "requestAnimationFrame",
            handler: c(e)
          },
          handled: !1,
          type: "instrument"
        }
      })
    ]);
  };
}
function L(e) {
  return function(...t) {
    const r = this;
    return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach((a) => {
      a in r && typeof r[a] == "function" && s(r, a, function(i) {
        const n = {
          mechanism: {
            data: {
              function: a,
              handler: c(i)
            },
            handled: !1,
            type: "instrument"
          }
        }, o = h(i);
        return o && (n.mechanism.data.handler = c(o)), p(i, n);
      });
    }), e.apply(this, t);
  };
}
function g(e, t) {
  const u = l[e]?.prototype;
  u?.hasOwnProperty?.("addEventListener") && (s(u, "addEventListener", function(a) {
    return function(i, n, o) {
      try {
        A(n) && (n.handleEvent = p(n.handleEvent, {
          mechanism: {
            data: {
              function: "handleEvent",
              handler: c(n),
              target: e
            },
            handled: !1,
            type: "instrument"
          }
        }));
      } catch {
      }
      return t.unregisterOriginalCallbacks && b(this, i, n), a.apply(this, [
        i,
        p(n, {
          mechanism: {
            data: {
              function: "addEventListener",
              handler: c(n),
              target: e
            },
            handled: !1,
            type: "instrument"
          }
        }),
        o
      ]);
    };
  }), s(u, "removeEventListener", function(a) {
    return function(i, n, o) {
      try {
        const d = n.__sentry_wrapped__;
        d && a.call(this, i, d, o);
      } catch {
      }
      return a.call(this, i, n, o);
    };
  }));
}
function A(e) {
  return typeof e.handleEvent == "function";
}
function b(e, t, r) {
  e && typeof e == "object" && "removeEventListener" in e && typeof e.removeEventListener == "function" && e.removeEventListener(t, r);
}
export {
  R as browserApiErrorsIntegration
};
