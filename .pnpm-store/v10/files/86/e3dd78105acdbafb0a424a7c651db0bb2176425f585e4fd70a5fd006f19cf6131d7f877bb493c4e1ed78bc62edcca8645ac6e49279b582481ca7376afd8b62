import * as t from "react";
import * as Re from "react-dom";
import { clamp as Te } from "./index234.js";
import { composeEventHandlers as R } from "./index97.js";
import { createCollection as et } from "./index231.js";
import { useComposedRefs as j } from "./index98.js";
import { createContextScope as tt } from "./index99.js";
import { useDirection as ot } from "./index233.js";
import { DismissableLayer as nt } from "./index100.js";
import { useFocusGuards as rt } from "./index101.js";
import { FocusScope as st } from "./index102.js";
import { useId as ye } from "./index103.js";
import { createPopperScope as Ee, Root as lt, Anchor as ct, Content as it, Arrow as at } from "./index104.js";
import { Portal as dt } from "./index105.js";
import { Primitive as M } from "./index107.js";
import { createSlot as ut } from "./index108.js";
import { useCallbackRef as pt } from "./index159.js";
import { useControllableState as Pe } from "./index109.js";
import { useLayoutEffect as z } from "./index161.js";
import { usePrevious as ft } from "./index235.js";
import { VISUALLY_HIDDEN_STYLES as mt } from "./index238.js";
import { hideOthers as ht } from "./index110.js";
import vt from "./index111.js";
import { j as d } from "./index7.js";
var gt = [" ", "Enter", "ArrowUp", "ArrowDown"], St = [" ", "Enter"], J = "Select", [ie, ae, xt] = et(J), [te] = tt(J, [
  xt,
  Ee
]), de = Ee(), [wt, Y] = te(J), [Ct, yt] = te(J), be = (o) => {
  const {
    __scopeSelect: c,
    children: e,
    open: i,
    defaultOpen: s,
    onOpenChange: u,
    value: n,
    defaultValue: r,
    onValueChange: l,
    dir: f,
    name: g,
    autoComplete: w,
    disabled: E,
    required: T,
    form: y
  } = o, a = de(c), [h, S] = t.useState(null), [m, v] = t.useState(null), [U, A] = t.useState(!1), oe = ot(f), [b, D] = Pe({
    prop: i,
    defaultProp: s ?? !1,
    onChange: u,
    caller: J
  }), [W, X] = Pe({
    prop: n,
    defaultProp: r,
    onChange: l,
    caller: J
  }), k = t.useRef(null), B = h ? y || !!h.closest("form") : !0, [K, V] = t.useState(/* @__PURE__ */ new Set()), H = Array.from(K).map((_) => _.props.value).join(";");
  return /* @__PURE__ */ d.jsx(lt, { ...a, children: /* @__PURE__ */ d.jsxs(
    wt,
    {
      required: T,
      scope: c,
      trigger: h,
      onTriggerChange: S,
      valueNode: m,
      onValueNodeChange: v,
      valueNodeHasChildren: U,
      onValueNodeHasChildrenChange: A,
      contentId: ye(),
      value: W,
      onValueChange: X,
      open: b,
      onOpenChange: D,
      dir: oe,
      triggerPointerDownPosRef: k,
      disabled: E,
      children: [
        /* @__PURE__ */ d.jsx(ie.Provider, { scope: c, children: /* @__PURE__ */ d.jsx(
          Ct,
          {
            scope: o.__scopeSelect,
            onNativeOptionAdd: t.useCallback((_) => {
              V((L) => new Set(L).add(_));
            }, []),
            onNativeOptionRemove: t.useCallback((_) => {
              V((L) => {
                const F = new Set(L);
                return F.delete(_), F;
              });
            }, []),
            children: e
          }
        ) }),
        B ? /* @__PURE__ */ d.jsxs(
          Ze,
          {
            "aria-hidden": !0,
            required: T,
            tabIndex: -1,
            name: g,
            autoComplete: w,
            value: W,
            onChange: (_) => X(_.target.value),
            disabled: E,
            form: y,
            children: [
              W === void 0 ? /* @__PURE__ */ d.jsx("option", { value: "" }) : null,
              Array.from(K)
            ]
          },
          H
        ) : null
      ]
    }
  ) });
};
be.displayName = J;
var _e = "SelectTrigger", Ne = t.forwardRef(
  (o, c) => {
    const { __scopeSelect: e, disabled: i = !1, ...s } = o, u = de(e), n = Y(_e, e), r = n.disabled || i, l = j(c, n.onTriggerChange), f = ae(e), g = t.useRef("touch"), [w, E, T] = Je((a) => {
      const h = f().filter((v) => !v.disabled), S = h.find((v) => v.value === n.value), m = Qe(h, a, S);
      m !== void 0 && n.onValueChange(m.value);
    }), y = (a) => {
      r || (n.onOpenChange(!0), T()), a && (n.triggerPointerDownPosRef.current = {
        x: Math.round(a.pageX),
        y: Math.round(a.pageY)
      });
    };
    return /* @__PURE__ */ d.jsx(ct, { asChild: !0, ...u, children: /* @__PURE__ */ d.jsx(
      M.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": n.contentId,
        "aria-expanded": n.open,
        "aria-required": n.required,
        "aria-autocomplete": "none",
        dir: n.dir,
        "data-state": n.open ? "open" : "closed",
        disabled: r,
        "data-disabled": r ? "" : void 0,
        "data-placeholder": $e(n.value) ? "" : void 0,
        ...s,
        ref: l,
        onClick: R(s.onClick, (a) => {
          a.currentTarget.focus(), g.current !== "mouse" && y(a);
        }),
        onPointerDown: R(s.onPointerDown, (a) => {
          g.current = a.pointerType;
          const h = a.target;
          h.hasPointerCapture(a.pointerId) && h.releasePointerCapture(a.pointerId), a.button === 0 && a.ctrlKey === !1 && a.pointerType === "mouse" && (y(a), a.preventDefault());
        }),
        onKeyDown: R(s.onKeyDown, (a) => {
          const h = w.current !== "";
          !(a.ctrlKey || a.altKey || a.metaKey) && a.key.length === 1 && E(a.key), !(h && a.key === " ") && gt.includes(a.key) && (y(), a.preventDefault());
        })
      }
    ) });
  }
);
Ne.displayName = _e;
var Me = "SelectValue", Ae = t.forwardRef(
  (o, c) => {
    const { __scopeSelect: e, className: i, style: s, children: u, placeholder: n = "", ...r } = o, l = Y(Me, e), { onValueNodeHasChildrenChange: f } = l, g = u !== void 0, w = j(c, l.onValueNodeChange);
    return z(() => {
      f(g);
    }, [f, g]), /* @__PURE__ */ d.jsx(
      M.span,
      {
        ...r,
        ref: w,
        style: { pointerEvents: "none" },
        children: $e(l.value) ? /* @__PURE__ */ d.jsx(d.Fragment, { children: n }) : u
      }
    );
  }
);
Ae.displayName = Me;
var It = "SelectIcon", Oe = t.forwardRef(
  (o, c) => {
    const { __scopeSelect: e, children: i, ...s } = o;
    return /* @__PURE__ */ d.jsx(M.span, { "aria-hidden": !0, ...s, ref: c, children: i || "â–¼" });
  }
);
Oe.displayName = It;
var Tt = "SelectPortal", De = (o) => /* @__PURE__ */ d.jsx(dt, { asChild: !0, ...o });
De.displayName = Tt;
var Q = "SelectContent", Le = t.forwardRef(
  (o, c) => {
    const e = Y(Q, o.__scopeSelect), [i, s] = t.useState();
    if (z(() => {
      s(new DocumentFragment());
    }, []), !e.open) {
      const u = i;
      return u ? Re.createPortal(
        /* @__PURE__ */ d.jsx(je, { scope: o.__scopeSelect, children: /* @__PURE__ */ d.jsx(ie.Slot, { scope: o.__scopeSelect, children: /* @__PURE__ */ d.jsx("div", { children: o.children }) }) }),
        u
      ) : null;
    }
    return /* @__PURE__ */ d.jsx(ke, { ...o, ref: c });
  }
);
Le.displayName = Q;
var O = 10, [je, q] = te(Q), Pt = "SelectContentImpl", Rt = ut("SelectContent.RemoveScroll"), ke = t.forwardRef(
  (o, c) => {
    const {
      __scopeSelect: e,
      position: i = "item-aligned",
      onCloseAutoFocus: s,
      onEscapeKeyDown: u,
      onPointerDownOutside: n,
      //
      // PopperContent props
      side: r,
      sideOffset: l,
      align: f,
      alignOffset: g,
      arrowPadding: w,
      collisionBoundary: E,
      collisionPadding: T,
      sticky: y,
      hideWhenDetached: a,
      avoidCollisions: h,
      //
      ...S
    } = o, m = Y(Q, e), [v, U] = t.useState(null), [A, oe] = t.useState(null), b = j(c, (p) => U(p)), [D, W] = t.useState(null), [X, k] = t.useState(
      null
    ), B = ae(e), [K, V] = t.useState(!1), H = t.useRef(!1);
    t.useEffect(() => {
      if (v) return ht(v);
    }, [v]), rt();
    const _ = t.useCallback(
      (p) => {
        const [I, ...N] = B().map((P) => P.ref.current), [x] = N.slice(-1), C = document.activeElement;
        for (const P of p)
          if (P === C || (P?.scrollIntoView({ block: "nearest" }), P === I && A && (A.scrollTop = 0), P === x && A && (A.scrollTop = A.scrollHeight), P?.focus(), document.activeElement !== C)) return;
      },
      [B, A]
    ), L = t.useCallback(
      () => _([D, v]),
      [_, D, v]
    );
    t.useEffect(() => {
      K && L();
    }, [K, L]);
    const { onOpenChange: F, triggerPointerDownPosRef: G } = m;
    t.useEffect(() => {
      if (v) {
        let p = { x: 0, y: 0 };
        const I = (x) => {
          p = {
            x: Math.abs(Math.round(x.pageX) - (G.current?.x ?? 0)),
            y: Math.abs(Math.round(x.pageY) - (G.current?.y ?? 0))
          };
        }, N = (x) => {
          p.x <= 10 && p.y <= 10 ? x.preventDefault() : v.contains(x.target) || F(!1), document.removeEventListener("pointermove", I), G.current = null;
        };
        return G.current !== null && (document.addEventListener("pointermove", I), document.addEventListener("pointerup", N, { capture: !0, once: !0 })), () => {
          document.removeEventListener("pointermove", I), document.removeEventListener("pointerup", N, { capture: !0 });
        };
      }
    }, [v, F, G]), t.useEffect(() => {
      const p = () => F(!1);
      return window.addEventListener("blur", p), window.addEventListener("resize", p), () => {
        window.removeEventListener("blur", p), window.removeEventListener("resize", p);
      };
    }, [F]);
    const [ue, se] = Je((p) => {
      const I = B().filter((C) => !C.disabled), N = I.find((C) => C.ref.current === document.activeElement), x = Qe(I, p, N);
      x && setTimeout(() => x.ref.current.focus());
    }), pe = t.useCallback(
      (p, I, N) => {
        const x = !H.current && !N;
        (m.value !== void 0 && m.value === I || x) && (W(p), x && (H.current = !0));
      },
      [m.value]
    ), fe = t.useCallback(() => v?.focus(), [v]), ee = t.useCallback(
      (p, I, N) => {
        const x = !H.current && !N;
        (m.value !== void 0 && m.value === I || x) && k(p);
      },
      [m.value]
    ), le = i === "popper" ? ge : Be, ne = le === ge ? {
      side: r,
      sideOffset: l,
      align: f,
      alignOffset: g,
      arrowPadding: w,
      collisionBoundary: E,
      collisionPadding: T,
      sticky: y,
      hideWhenDetached: a,
      avoidCollisions: h
    } : {};
    return /* @__PURE__ */ d.jsx(
      je,
      {
        scope: e,
        content: v,
        viewport: A,
        onViewportChange: oe,
        itemRefCallback: pe,
        selectedItem: D,
        onItemLeave: fe,
        itemTextRefCallback: ee,
        focusSelectedItem: L,
        selectedItemText: X,
        position: i,
        isPositioned: K,
        searchRef: ue,
        children: /* @__PURE__ */ d.jsx(vt, { as: Rt, allowPinchZoom: !0, children: /* @__PURE__ */ d.jsx(
          st,
          {
            asChild: !0,
            trapped: m.open,
            onMountAutoFocus: (p) => {
              p.preventDefault();
            },
            onUnmountAutoFocus: R(s, (p) => {
              m.trigger?.focus({ preventScroll: !0 }), p.preventDefault();
            }),
            children: /* @__PURE__ */ d.jsx(
              nt,
              {
                asChild: !0,
                disableOutsidePointerEvents: !0,
                onEscapeKeyDown: u,
                onPointerDownOutside: n,
                onFocusOutside: (p) => p.preventDefault(),
                onDismiss: () => m.onOpenChange(!1),
                children: /* @__PURE__ */ d.jsx(
                  le,
                  {
                    role: "listbox",
                    id: m.contentId,
                    "data-state": m.open ? "open" : "closed",
                    dir: m.dir,
                    onContextMenu: (p) => p.preventDefault(),
                    ...S,
                    ...ne,
                    onPlaced: () => V(!0),
                    ref: b,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...S.style
                    },
                    onKeyDown: R(S.onKeyDown, (p) => {
                      const I = p.ctrlKey || p.altKey || p.metaKey;
                      if (p.key === "Tab" && p.preventDefault(), !I && p.key.length === 1 && se(p.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(p.key)) {
                        let x = B().filter((C) => !C.disabled).map((C) => C.ref.current);
                        if (["ArrowUp", "End"].includes(p.key) && (x = x.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(p.key)) {
                          const C = p.target, P = x.indexOf(C);
                          x = x.slice(P + 1);
                        }
                        setTimeout(() => _(x)), p.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
ke.displayName = Pt;
var Et = "SelectItemAlignedPosition", Be = t.forwardRef((o, c) => {
  const { __scopeSelect: e, onPlaced: i, ...s } = o, u = Y(Q, e), n = q(Q, e), [r, l] = t.useState(null), [f, g] = t.useState(null), w = j(c, (b) => g(b)), E = ae(e), T = t.useRef(!1), y = t.useRef(!0), { viewport: a, selectedItem: h, selectedItemText: S, focusSelectedItem: m } = n, v = t.useCallback(() => {
    if (u.trigger && u.valueNode && r && f && a && h && S) {
      const b = u.trigger.getBoundingClientRect(), D = f.getBoundingClientRect(), W = u.valueNode.getBoundingClientRect(), X = S.getBoundingClientRect();
      if (u.dir !== "rtl") {
        const C = X.left - D.left, P = W.left - C, Z = b.left - P, $ = b.width + Z, me = Math.max($, D.width), he = window.innerWidth - O, ve = Te(P, [
          O,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(O, he - me)
        ]);
        r.style.minWidth = $ + "px", r.style.left = ve + "px";
      } else {
        const C = D.right - X.right, P = window.innerWidth - W.right - C, Z = window.innerWidth - b.right - P, $ = b.width + Z, me = Math.max($, D.width), he = window.innerWidth - O, ve = Te(P, [
          O,
          Math.max(O, he - me)
        ]);
        r.style.minWidth = $ + "px", r.style.right = ve + "px";
      }
      const k = E(), B = window.innerHeight - O * 2, K = a.scrollHeight, V = window.getComputedStyle(f), H = parseInt(V.borderTopWidth, 10), _ = parseInt(V.paddingTop, 10), L = parseInt(V.borderBottomWidth, 10), F = parseInt(V.paddingBottom, 10), G = H + _ + K + F + L, ue = Math.min(h.offsetHeight * 5, G), se = window.getComputedStyle(a), pe = parseInt(se.paddingTop, 10), fe = parseInt(se.paddingBottom, 10), ee = b.top + b.height / 2 - O, le = B - ee, ne = h.offsetHeight / 2, p = h.offsetTop + ne, I = H + _ + p, N = G - I;
      if (I <= ee) {
        const C = k.length > 0 && h === k[k.length - 1].ref.current;
        r.style.bottom = "0px";
        const P = f.clientHeight - a.offsetTop - a.offsetHeight, Z = Math.max(
          le,
          ne + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (C ? fe : 0) + P + L
        ), $ = I + Z;
        r.style.height = $ + "px";
      } else {
        const C = k.length > 0 && h === k[0].ref.current;
        r.style.top = "0px";
        const Z = Math.max(
          ee,
          H + a.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (C ? pe : 0) + ne
        ) + N;
        r.style.height = Z + "px", a.scrollTop = I - ee + a.offsetTop;
      }
      r.style.margin = `${O}px 0`, r.style.minHeight = ue + "px", r.style.maxHeight = B + "px", i?.(), requestAnimationFrame(() => T.current = !0);
    }
  }, [
    E,
    u.trigger,
    u.valueNode,
    r,
    f,
    a,
    h,
    S,
    u.dir,
    i
  ]);
  z(() => v(), [v]);
  const [U, A] = t.useState();
  z(() => {
    f && A(window.getComputedStyle(f).zIndex);
  }, [f]);
  const oe = t.useCallback(
    (b) => {
      b && y.current === !0 && (v(), m?.(), y.current = !1);
    },
    [v, m]
  );
  return /* @__PURE__ */ d.jsx(
    _t,
    {
      scope: e,
      contentWrapper: r,
      shouldExpandOnScrollRef: T,
      onScrollButtonChange: oe,
      children: /* @__PURE__ */ d.jsx(
        "div",
        {
          ref: l,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: U
          },
          children: /* @__PURE__ */ d.jsx(
            M.div,
            {
              ...s,
              ref: w,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...s.style
              }
            }
          )
        }
      )
    }
  );
});
Be.displayName = Et;
var bt = "SelectPopperPosition", ge = t.forwardRef((o, c) => {
  const {
    __scopeSelect: e,
    align: i = "start",
    collisionPadding: s = O,
    ...u
  } = o, n = de(e);
  return /* @__PURE__ */ d.jsx(
    it,
    {
      ...n,
      ...u,
      ref: c,
      align: i,
      collisionPadding: s,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...u.style,
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
ge.displayName = bt;
var [_t, Ie] = te(Q, {}), Se = "SelectViewport", Ve = t.forwardRef(
  (o, c) => {
    const { __scopeSelect: e, nonce: i, ...s } = o, u = q(Se, e), n = Ie(Se, e), r = j(c, u.onViewportChange), l = t.useRef(0);
    return /* @__PURE__ */ d.jsxs(d.Fragment, { children: [
      /* @__PURE__ */ d.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: i
        }
      ),
      /* @__PURE__ */ d.jsx(ie.Slot, { scope: e, children: /* @__PURE__ */ d.jsx(
        M.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...s,
          ref: r,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...s.style
          },
          onScroll: R(s.onScroll, (f) => {
            const g = f.currentTarget, { contentWrapper: w, shouldExpandOnScrollRef: E } = n;
            if (E?.current && w) {
              const T = Math.abs(l.current - g.scrollTop);
              if (T > 0) {
                const y = window.innerHeight - O * 2, a = parseFloat(w.style.minHeight), h = parseFloat(w.style.height), S = Math.max(a, h);
                if (S < y) {
                  const m = S + T, v = Math.min(y, m), U = m - v;
                  w.style.height = v + "px", w.style.bottom === "0px" && (g.scrollTop = U > 0 ? U : 0, w.style.justifyContent = "flex-end");
                }
              }
            }
            l.current = g.scrollTop;
          })
        }
      ) })
    ] });
  }
);
Ve.displayName = Se;
var He = "SelectGroup", [Nt, Mt] = te(He), At = t.forwardRef(
  (o, c) => {
    const { __scopeSelect: e, ...i } = o, s = ye();
    return /* @__PURE__ */ d.jsx(Nt, { scope: e, id: s, children: /* @__PURE__ */ d.jsx(M.div, { role: "group", "aria-labelledby": s, ...i, ref: c }) });
  }
);
At.displayName = He;
var Fe = "SelectLabel", Ot = t.forwardRef(
  (o, c) => {
    const { __scopeSelect: e, ...i } = o, s = Mt(Fe, e);
    return /* @__PURE__ */ d.jsx(M.div, { id: s.id, ...i, ref: c });
  }
);
Ot.displayName = Fe;
var ce = "SelectItem", [Dt, Ue] = te(ce), We = t.forwardRef(
  (o, c) => {
    const {
      __scopeSelect: e,
      value: i,
      disabled: s = !1,
      textValue: u,
      ...n
    } = o, r = Y(ce, e), l = q(ce, e), f = r.value === i, [g, w] = t.useState(u ?? ""), [E, T] = t.useState(!1), y = j(
      c,
      (m) => l.itemRefCallback?.(m, i, s)
    ), a = ye(), h = t.useRef("touch"), S = () => {
      s || (r.onValueChange(i), r.onOpenChange(!1));
    };
    if (i === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return /* @__PURE__ */ d.jsx(
      Dt,
      {
        scope: e,
        value: i,
        disabled: s,
        textId: a,
        isSelected: f,
        onItemTextChange: t.useCallback((m) => {
          w((v) => v || (m?.textContent ?? "").trim());
        }, []),
        children: /* @__PURE__ */ d.jsx(
          ie.ItemSlot,
          {
            scope: e,
            value: i,
            disabled: s,
            textValue: g,
            children: /* @__PURE__ */ d.jsx(
              M.div,
              {
                role: "option",
                "aria-labelledby": a,
                "data-highlighted": E ? "" : void 0,
                "aria-selected": f && E,
                "data-state": f ? "checked" : "unchecked",
                "aria-disabled": s || void 0,
                "data-disabled": s ? "" : void 0,
                tabIndex: s ? void 0 : -1,
                ...n,
                ref: y,
                onFocus: R(n.onFocus, () => T(!0)),
                onBlur: R(n.onBlur, () => T(!1)),
                onClick: R(n.onClick, () => {
                  h.current !== "mouse" && S();
                }),
                onPointerUp: R(n.onPointerUp, () => {
                  h.current === "mouse" && S();
                }),
                onPointerDown: R(n.onPointerDown, (m) => {
                  h.current = m.pointerType;
                }),
                onPointerMove: R(n.onPointerMove, (m) => {
                  h.current = m.pointerType, s ? l.onItemLeave?.() : h.current === "mouse" && m.currentTarget.focus({ preventScroll: !0 });
                }),
                onPointerLeave: R(n.onPointerLeave, (m) => {
                  m.currentTarget === document.activeElement && l.onItemLeave?.();
                }),
                onKeyDown: R(n.onKeyDown, (m) => {
                  l.searchRef?.current !== "" && m.key === " " || (St.includes(m.key) && S(), m.key === " " && m.preventDefault());
                })
              }
            )
          }
        )
      }
    );
  }
);
We.displayName = ce;
var re = "SelectItemText", Ke = t.forwardRef(
  (o, c) => {
    const { __scopeSelect: e, className: i, style: s, ...u } = o, n = Y(re, e), r = q(re, e), l = Ue(re, e), f = yt(re, e), [g, w] = t.useState(null), E = j(
      c,
      (S) => w(S),
      l.onItemTextChange,
      (S) => r.itemTextRefCallback?.(S, l.value, l.disabled)
    ), T = g?.textContent, y = t.useMemo(
      () => /* @__PURE__ */ d.jsx("option", { value: l.value, disabled: l.disabled, children: T }, l.value),
      [l.disabled, l.value, T]
    ), { onNativeOptionAdd: a, onNativeOptionRemove: h } = f;
    return z(() => (a(y), () => h(y)), [a, h, y]), /* @__PURE__ */ d.jsxs(d.Fragment, { children: [
      /* @__PURE__ */ d.jsx(M.span, { id: l.textId, ...u, ref: E }),
      l.isSelected && n.valueNode && !n.valueNodeHasChildren ? Re.createPortal(u.children, n.valueNode) : null
    ] });
  }
);
Ke.displayName = re;
var Ge = "SelectItemIndicator", ze = t.forwardRef(
  (o, c) => {
    const { __scopeSelect: e, ...i } = o;
    return Ue(Ge, e).isSelected ? /* @__PURE__ */ d.jsx(M.span, { "aria-hidden": !0, ...i, ref: c }) : null;
  }
);
ze.displayName = Ge;
var xe = "SelectScrollUpButton", Ye = t.forwardRef((o, c) => {
  const e = q(xe, o.__scopeSelect), i = Ie(xe, o.__scopeSelect), [s, u] = t.useState(!1), n = j(c, i.onScrollButtonChange);
  return z(() => {
    if (e.viewport && e.isPositioned) {
      let r = function() {
        const f = l.scrollTop > 0;
        u(f);
      };
      const l = e.viewport;
      return r(), l.addEventListener("scroll", r), () => l.removeEventListener("scroll", r);
    }
  }, [e.viewport, e.isPositioned]), s ? /* @__PURE__ */ d.jsx(
    Xe,
    {
      ...o,
      ref: n,
      onAutoScroll: () => {
        const { viewport: r, selectedItem: l } = e;
        r && l && (r.scrollTop = r.scrollTop - l.offsetHeight);
      }
    }
  ) : null;
});
Ye.displayName = xe;
var we = "SelectScrollDownButton", qe = t.forwardRef((o, c) => {
  const e = q(we, o.__scopeSelect), i = Ie(we, o.__scopeSelect), [s, u] = t.useState(!1), n = j(c, i.onScrollButtonChange);
  return z(() => {
    if (e.viewport && e.isPositioned) {
      let r = function() {
        const f = l.scrollHeight - l.clientHeight, g = Math.ceil(l.scrollTop) < f;
        u(g);
      };
      const l = e.viewport;
      return r(), l.addEventListener("scroll", r), () => l.removeEventListener("scroll", r);
    }
  }, [e.viewport, e.isPositioned]), s ? /* @__PURE__ */ d.jsx(
    Xe,
    {
      ...o,
      ref: n,
      onAutoScroll: () => {
        const { viewport: r, selectedItem: l } = e;
        r && l && (r.scrollTop = r.scrollTop + l.offsetHeight);
      }
    }
  ) : null;
});
qe.displayName = we;
var Xe = t.forwardRef((o, c) => {
  const { __scopeSelect: e, onAutoScroll: i, ...s } = o, u = q("SelectScrollButton", e), n = t.useRef(null), r = ae(e), l = t.useCallback(() => {
    n.current !== null && (window.clearInterval(n.current), n.current = null);
  }, []);
  return t.useEffect(() => () => l(), [l]), z(() => {
    r().find((g) => g.ref.current === document.activeElement)?.ref.current?.scrollIntoView({ block: "nearest" });
  }, [r]), /* @__PURE__ */ d.jsx(
    M.div,
    {
      "aria-hidden": !0,
      ...s,
      ref: c,
      style: { flexShrink: 0, ...s.style },
      onPointerDown: R(s.onPointerDown, () => {
        n.current === null && (n.current = window.setInterval(i, 50));
      }),
      onPointerMove: R(s.onPointerMove, () => {
        u.onItemLeave?.(), n.current === null && (n.current = window.setInterval(i, 50));
      }),
      onPointerLeave: R(s.onPointerLeave, () => {
        l();
      })
    }
  );
}), Lt = "SelectSeparator", jt = t.forwardRef(
  (o, c) => {
    const { __scopeSelect: e, ...i } = o;
    return /* @__PURE__ */ d.jsx(M.div, { "aria-hidden": !0, ...i, ref: c });
  }
);
jt.displayName = Lt;
var Ce = "SelectArrow", kt = t.forwardRef(
  (o, c) => {
    const { __scopeSelect: e, ...i } = o, s = de(e), u = Y(Ce, e), n = q(Ce, e);
    return u.open && n.position === "popper" ? /* @__PURE__ */ d.jsx(at, { ...s, ...i, ref: c }) : null;
  }
);
kt.displayName = Ce;
var Bt = "SelectBubbleInput", Ze = t.forwardRef(
  ({ __scopeSelect: o, value: c, ...e }, i) => {
    const s = t.useRef(null), u = j(i, s), n = ft(c);
    return t.useEffect(() => {
      const r = s.current;
      if (!r) return;
      const l = window.HTMLSelectElement.prototype, g = Object.getOwnPropertyDescriptor(
        l,
        "value"
      ).set;
      if (n !== c && g) {
        const w = new Event("change", { bubbles: !0 });
        g.call(r, c), r.dispatchEvent(w);
      }
    }, [n, c]), /* @__PURE__ */ d.jsx(
      M.select,
      {
        ...e,
        style: { ...mt, ...e.style },
        ref: u,
        defaultValue: c
      }
    );
  }
);
Ze.displayName = Bt;
function $e(o) {
  return o === "" || o === void 0;
}
function Je(o) {
  const c = pt(o), e = t.useRef(""), i = t.useRef(0), s = t.useCallback(
    (n) => {
      const r = e.current + n;
      c(r), function l(f) {
        e.current = f, window.clearTimeout(i.current), f !== "" && (i.current = window.setTimeout(() => l(""), 1e3));
      }(r);
    },
    [c]
  ), u = t.useCallback(() => {
    e.current = "", window.clearTimeout(i.current);
  }, []);
  return t.useEffect(() => () => window.clearTimeout(i.current), []), [e, s, u];
}
function Qe(o, c, e) {
  const s = c.length > 1 && Array.from(c).every((f) => f === c[0]) ? c[0] : c, u = e ? o.indexOf(e) : -1;
  let n = Vt(o, Math.max(u, 0));
  s.length === 1 && (n = n.filter((f) => f !== e));
  const l = n.find(
    (f) => f.textValue.toLowerCase().startsWith(s.toLowerCase())
  );
  return l !== e ? l : void 0;
}
function Vt(o, c) {
  return o.map((e, i) => o[(c + i) % o.length]);
}
var io = be, ao = Ne, uo = Ae, po = Oe, fo = De, mo = Le, ho = Ve, vo = We, go = Ke, So = ze, xo = Ye, wo = qe;
export {
  mo as Content,
  po as Icon,
  vo as Item,
  So as ItemIndicator,
  go as ItemText,
  fo as Portal,
  io as Root,
  wo as ScrollDownButton,
  xo as ScrollUpButton,
  be as Select,
  kt as SelectArrow,
  Le as SelectContent,
  At as SelectGroup,
  Oe as SelectIcon,
  We as SelectItem,
  ze as SelectItemIndicator,
  Ke as SelectItemText,
  Ot as SelectLabel,
  De as SelectPortal,
  qe as SelectScrollDownButton,
  Ye as SelectScrollUpButton,
  jt as SelectSeparator,
  Ne as SelectTrigger,
  Ae as SelectValue,
  Ve as SelectViewport,
  ao as Trigger,
  uo as Value,
  ho as Viewport
};
