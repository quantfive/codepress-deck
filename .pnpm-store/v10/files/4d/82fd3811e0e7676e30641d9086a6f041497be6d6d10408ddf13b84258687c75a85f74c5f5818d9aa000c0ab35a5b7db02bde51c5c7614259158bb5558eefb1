import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { DeploymentProvider } from "@/context/DeploymentContext";
import { useCallback, useEffect, useRef, useState } from "react";
import { PopoverContainerProvider } from "../context/PopoverContainerContext.js";
import { RepositoryProvider } from "../context/RepositoryContext.js";
import { useVisualEditor, VisualEditorProvider, } from "../context/VisualEditorContext.js";
import { debugDragDropSetup } from "../lib/drag-drop-debug.js";
import logger from "../lib/logger.js";
import { SimpleDragDrop } from "../lib/simple-drag-drop.js";
import { applyStylesToTarget, getElementValues } from "../utils/elementStyles.js";
import { getCleanElementHTML } from "../utils/saveChanges.js";
import DesignBar from "./designBar/DesignBar.js";
import { DesignPanel } from "./DesignPanel.js";
import MenuOverlay from "./menu/MenuOverlay.js";
import SaveBar from "./saveBar/SaveBar.js";
import { DeploymentPopover } from "@/components/saveBar/DeploymentPopover";
import { GitHubProvider } from "@/context/GithubContext";
function EditorUI({ isEditing, isDesignPanelOpen, setIsDesignPanelOpen, selectedElement, popoverContainer, elementValues, handleCloseCb, handleOpenDesignPanel, }) {
    const { totalUnsavedChanges, saveAllChanges, cancelAllChanges, isSaving, activeElementFpId, } = useVisualEditor();
    useEffect(() => {
        const handleStyleUpdate = (event) => {
            const { fpId, _isRevert, ...updates } = event.detail;
            if (!fpId)
                return; // Safety guard
            // Apply the update to *all* elements that share this fpId.
            const elements = document.querySelectorAll(`[codepress-data-fp="${fpId}"]`);
            elements.forEach((el) => {
                applyStylesToTarget(el, updates);
            });
        };
        document.addEventListener("design-panel-style-update", handleStyleUpdate);
        return () => {
            document.removeEventListener("design-panel-style-update", handleStyleUpdate);
        };
    }, [selectedElement, activeElementFpId]);
    return (_jsxs(PopoverContainerProvider, { container: popoverContainer, children: [!isDesignPanelOpen &&
                selectedElement &&
                popoverContainer &&
                elementValues && (_jsx(DesignBar, { onClose: handleCloseCb, popoverContainer: popoverContainer, onOpenDesignPanel: handleOpenDesignPanel })), isDesignPanelOpen &&
                selectedElement &&
                elementValues &&
                popoverContainer && (_jsx(DesignPanel, { onClose: () => setIsDesignPanelOpen(false), shadowRoot: popoverContainer })), isEditing && (_jsx(SaveBar, { onSave: saveAllChanges, onCancel: cancelAllChanges, unsavedChanges: totalUnsavedChanges, isSaving: isSaving }))] }));
}
export default function Editor({ demo = false, onToggleReady, }) {
    const [selectedElement, setSelectedElement] = useState(null);
    const [hoveredElement, setHoveredElement] = useState(null);
    const [popoverContainer, setPopoverContainer] = useState(null);
    const [elementValues, setElementValues] = useState(null);
    // Initialize isEditing from localStorage if available
    const [isEditing, setIsEditing] = useState(() => {
        if (typeof window !== "undefined") {
            const saved = localStorage.getItem("codepress-editing-mode");
            return saved ? JSON.parse(saved) : false;
        }
        return false;
    });
    const [isDesignPanelOpen, setIsDesignPanelOpen] = useState(false);
    // Drag & Drop instance ref
    const dragDropRef = useRef(null);
    // Save isEditing state to localStorage whenever it changes
    useEffect(() => {
        if (typeof window !== "undefined") {
            localStorage.setItem("codepress-editing-mode", JSON.stringify(isEditing));
        }
    }, [isEditing]);
    // Use a ref to store the latest state. This allows our event handlers, which are registered only once,
    // to access the latest state values without needing to re-registered.
    const stateRef = useRef({ selectedElement, hoveredElement, isEditing });
    stateRef.current = { selectedElement, hoveredElement, isEditing };
    // Track the mouse down position *and* whether the press originated inside our UI
    const lastMouseDownRef = useRef(null);
    const DRAG_THRESHOLD_PX = 6;
    const getEventTarget = (e) => {
        const path = e.composedPath();
        const target = path.length > 0 ? path[0] : e.target;
        return target instanceof HTMLElement ? target : null;
    };
    const isUiElement = (element) => {
        if (!element)
            return false;
        // Check if the element or any of its ancestors are part of our UI
        return !!(element.closest("[data-codepress-root], [data-codepress-portal]") ||
            element.classList.contains("simple-long-press-active") ||
            element.classList.contains("simple-ghost-element") ||
            element.classList.contains("simple-drop-indicator") ||
            element.dataset.codepressHandle === "true");
    };
    // Detect if an element is inside an <a> tag or a <button> (treated as interactive)
    // so that we avoid hijacking clicks for contentEditable when users intend to
    // navigate or trigger button actions.
    const isInsideAnchorOrClickableButton = (element) => {
        if (!element)
            return false;
        if (isUiElement(element))
            return false;
        const anchorAncestor = element.closest("a");
        if (anchorAncestor)
            return true;
        const buttonAncestor = element.closest("button");
        if (buttonAncestor) {
            // In practice, buttons are interactive regardless of how click handlers are attached
            // (attribute, property, or addEventListener/React synthetic events). Treat all as interactive.
            return true;
        }
        return false;
    };
    const handleClose = useCallback(() => {
        const lastSelected = stateRef.current.selectedElement;
        if (lastSelected) {
            lastSelected.style.outline = "";
            lastSelected.contentEditable =
                lastSelected.dataset.originalContentEditable ?? "inherit";
            delete lastSelected.dataset.originalContentEditable;
            // No need to manage drag handles - elements are draggable via long-press
        }
        setSelectedElement(null);
        setIsDesignPanelOpen(false);
        // clear selection
        const sel = window.getSelection();
        if (sel)
            sel.removeAllRanges();
        const event = new CustomEvent("codepress-deselect-element");
        document.dispatchEvent(event);
    }, []);
    const handleMouseDown = useCallback((e) => {
        const target = getEventTarget(e);
        lastMouseDownRef.current = {
            x: e.clientX,
            y: e.clientY,
            startInUi: isUiElement(target),
        };
    }, []);
    const clearHover = useCallback(() => {
        const currentHover = stateRef.current.hoveredElement;
        if (currentHover && !isUiElement(currentHover.element)) {
            currentHover.element.style.outline = currentHover.originalOutline;
            // No need to remove drag handles - elements are now draggable via long-press
        }
        setHoveredElement(null);
    }, []);
    const handleMouseOver = useCallback((e) => {
        const target = getEventTarget(e);
        if (!target ||
            isUiElement(target) ||
            target === stateRef.current.selectedElement) {
            if (stateRef.current.hoveredElement)
                clearHover();
            return;
        }
        if (stateRef.current.hoveredElement?.element !== target) {
            clearHover();
            setHoveredElement({
                element: target,
                originalOutline: target.style.outline,
            });
            target.style.outline = "2px dashed #2563eb"; // blue-600
            // Elements are now draggable via long-press automatically - no handles needed
        }
    }, [clearHover]);
    const handleMouseOut = useCallback((e) => {
        const target = getEventTarget(e);
        if (!target ||
            (stateRef.current.hoveredElement &&
                stateRef.current.hoveredElement.element === target)) {
            clearHover();
        }
    }, [clearHover]);
    const handleClick = useCallback((e) => {
        // If user currently has a non-collapsed selection, don't hijack click
        // UNLESS the click is within an anchor or button. In that case, prevent
        // navigation/click so the user can select/edit text safely.
        const sel = window.getSelection();
        if (sel && sel.rangeCount > 0 && !sel.isCollapsed) {
            const t = getEventTarget(e);
            if (!t || isUiElement(t))
                return;
            if (!isInsideAnchorOrClickableButton(t)) {
                return;
            }
            // Fall through for anchors/buttons so we can intercept default behavior below
        }
        const start = lastMouseDownRef.current;
        if (start) {
            const dx = e.clientX - start.x;
            const dy = e.clientY - start.y;
            // Only treat as a UI drag if the mouse press *began* inside one of our UI elements
            if (start.startInUi && Math.hypot(dx, dy) > DRAG_THRESHOLD_PX) {
                // Drag detected; clear the ref and skip click handling
                lastMouseDownRef.current = null;
                return;
            }
        }
        const target = getEventTarget(e);
        if (!target || isUiElement(target)) {
            return;
        }
        // If the click is within an anchor or button, still intercept so we
        // prevent navigation or button actions during editing.
        e.preventDefault();
        e.stopPropagation();
        lastMouseDownRef.current = null;
        // Close any existing selection first. This logic is similar to `handleClose`
        // but we're acting on the current selected element from the ref.
        const currentSelected = stateRef.current.selectedElement;
        if (currentSelected && currentSelected !== target) {
            currentSelected.style.outline = "";
            currentSelected.contentEditable =
                currentSelected.dataset.originalContentEditable ?? "inherit";
            delete currentSelected.dataset.originalContentEditable;
            // No need to manage drag handles - elements are draggable via long-press
        }
        clearHover();
        target.style.outline = "2px solid #2563eb"; // blue-600
        target.dataset.originalContentEditable = target.contentEditable;
        target.contentEditable = "true";
        setSelectedElement(target);
        const newElementValues = getElementValues(target);
        setElementValues(newElementValues);
        // Elements are now draggable via long-press automatically - no handles needed
        const event = new CustomEvent("codepress-select-element", {
            detail: {
                element: target,
                initialValues: newElementValues,
            },
        });
        document.dispatchEvent(event);
        if (target) {
            originalHtmlRef.current = getCleanElementHTML(target, false);
        }
        target.focus();
    }, [clearHover]);
    const interactionListenersActive = useRef(false);
    // Visual editor context will be integrated later for tracking unsaved changes
    // Handle drag & drop move operations
    const handleDropElement = useCallback(async (moveOperation) => {
        logger.info("Drag & Drop: Element dropped", moveOperation);
        const { source, target, position } = moveOperation;
        try {
            logger.info("🔧 MOVE OPERATION DEBUG:", {
                operation: "optimisticMoveAndTrack",
                source: {
                    location: source.location,
                    tagName: source.tagName,
                },
                target: {
                    location: target.location,
                    tagName: target.tagName,
                },
                position,
                timestamp: Date.now(),
            });
            // 1. First, optimistically apply the DOM move (like we did before)
            switch (position) {
                case "before":
                    if (target.element.parentNode) {
                        target.element.parentNode.insertBefore(source.element, target.element);
                        logger.info("✅ Element moved BEFORE target");
                    }
                    break;
                case "after":
                    if (target.element.parentNode) {
                        const nextSibling = target.element.nextSibling;
                        if (nextSibling) {
                            target.element.parentNode.insertBefore(source.element, nextSibling);
                        }
                        else {
                            target.element.parentNode.appendChild(source.element);
                        }
                        logger.info("✅ Element moved AFTER target");
                    }
                    break;
                case "left":
                    if (target.element.parentNode) {
                        target.element.parentNode.insertBefore(source.element, target.element);
                        logger.info("✅ Element moved LEFT of target");
                    }
                    break;
                case "right":
                    if (target.element.parentNode) {
                        const nextSibling = target.element.nextSibling;
                        if (nextSibling) {
                            target.element.parentNode.insertBefore(source.element, nextSibling);
                        }
                        else {
                            target.element.parentNode.appendChild(source.element);
                        }
                        logger.info("✅ Element moved RIGHT of target");
                    }
                    break;
                case "inside":
                    target.element.appendChild(source.element);
                    logger.info("✅ Element moved INSIDE target");
                    break;
                default:
                    logger.error("❌ Unknown drop position:", position);
                    return;
            }
            // 2. Track as unsaved change for the save toolbar
            // Create the move change object
            const moveChange = {
                sourceLocation: source.location || "",
                targetLocation: target.location || "",
                position: position,
                sourceTag: source.tagName?.toLowerCase(),
                targetTag: target.tagName?.toLowerCase(),
            };
            // 3. Track as unsaved change using visual editor context
            // For now, we'll dispatch a custom event to notify that a move occurred
            // This allows the save toolbar to show unsaved changes
            if (source.location) {
                const moveEvent = new CustomEvent("codepress-element-moved", {
                    detail: {
                        moveChange,
                        sourceElement: source.element,
                        targetElement: target.element,
                    },
                    bubbles: true,
                    composed: true,
                });
                document.dispatchEvent(moveEvent);
                logger.info("📝 Move tracked as unsaved change:", {
                    sourceLocation: source.location,
                    moveChange,
                });
            }
            // Clear any selection since the element has moved
            if (selectedElement === source.element) {
                handleClose();
            }
            logger.info("🎉 Move operation completed successfully!");
        }
        catch (error) {
            logger.error("❌ Failed to move element:", error);
        }
    }, [selectedElement, handleClose]);
    const initializeInteractionListeners = useCallback(() => {
        if (interactionListenersActive.current)
            return;
        document.addEventListener("mouseover", handleMouseOver, true);
        document.addEventListener("mouseout", handleMouseOut, true);
        document.addEventListener("mousedown", handleMouseDown, true);
        document.addEventListener("click", handleClick, true);
        interactionListenersActive.current = true;
    }, [handleClick, handleMouseOut, handleMouseOver, handleMouseDown]);
    const removeInteractionListeners = useCallback(() => {
        if (!interactionListenersActive.current)
            return;
        document.removeEventListener("mouseover", handleMouseOver, true);
        document.removeEventListener("mouseout", handleMouseOut, true);
        document.removeEventListener("mousedown", handleMouseDown, true);
        document.removeEventListener("click", handleClick, true);
        clearHover();
        // No need to clean up selected element here, as it's handled by handleClose
        interactionListenersActive.current = false;
    }, [
        clearHover,
        handleClick,
        handleMouseOut,
        handleMouseOver,
        handleMouseDown,
    ]);
    useEffect(() => {
        if (isEditing) {
            initializeInteractionListeners();
        }
        else {
            removeInteractionListeners();
        }
    }, [isEditing, initializeInteractionListeners, removeInteractionListeners]);
    // Manage drag & drop functionality
    useEffect(() => {
        if (isEditing) {
            // Initialize drag & drop when entering edit mode
            if (!dragDropRef.current) {
                logger.info("Drag & Drop: Initializing simple drag and drop functionality");
                // Debug the setup (silent mode - no visual test handles)
                setTimeout(() => {
                    const debugInfo = debugDragDropSetup();
                    // Only log if there are issues
                    if (debugInfo.elementsWithCodePressData === 0) {
                        logger.warn("⚠️ No elements with codepress-data-fp found! Drag & drop won't work.");
                    }
                    // Log debug info at debug level only
                    if (debugInfo.errors.length > 0) {
                        logger.info("🔍 Drag & Drop Debug Issues:", debugInfo.errors);
                    }
                }, 1000);
                dragDropRef.current = new SimpleDragDrop({
                    onDropElement: handleDropElement,
                    // Customize the appearance to match CodePress theme
                    dropZoneColor: "#2563eb",
                    ghostOpacity: 0.6,
                    longPressDuration: 500, // 125ms hold to activate drag
                    movementThreshold: 5, // 5px max movement during hold
                });
            }
        }
        else {
            // Clean up drag & drop when exiting edit mode
            if (dragDropRef.current) {
                logger.info("Drag & Drop: Cleaning up simple drag and drop functionality");
                dragDropRef.current.destroy();
                dragDropRef.current = null;
            }
        }
        // Cleanup on unmount
        return () => {
            if (dragDropRef.current) {
                dragDropRef.current.destroy();
                dragDropRef.current = null;
            }
        };
    }, [isEditing, handleDropElement]);
    // useEffect(() => {
    //   const messageListener = (
    //     message: { action: string },
    //     // @ts-ignore - browser ts cant find browser here? but works later
    //     sender: browser.runtime.MessageSender,
    //     sendResponse: (response?: any) => void
    //   ) => {
    //     if (message.action === 'startInteraction') {
    //       setIsEditing(true);
    //       sendResponse({status: 'interaction started'});
    //     } else if (message.action === 'stopInteraction') {
    //       setIsEditing(false);
    //       sendResponse({status: 'interaction stopped'});
    //     }
    //   };
    //   browser.runtime.onMessage.addListener(messageListener);
    //   return () => {
    //     removeInteractionListeners();
    //     browser.runtime.onMessage.removeListener(messageListener);
    //   };
    // }, [removeInteractionListeners]);
    const handleToggleEditing = () => {
        setIsEditing((prevIsEditing) => {
            const newIsEditing = !prevIsEditing;
            if (!newIsEditing) {
                handleClose();
            }
            return newIsEditing;
        });
    };
    // Expose toggle function to parent component (for extension integration)
    useEffect(() => {
        if (onToggleReady) {
            onToggleReady(handleToggleEditing);
        }
    }, [onToggleReady]); // Remove handleToggleEditing from deps to prevent infinite loop
    const handleOpenDesignPanel = () => {
        setIsDesignPanelOpen(true);
    };
    // The existing handleClose is now used by DesignBar's close button and when toggling editing off.
    // It's defined with useCallback to keep its identity stable.
    const handleCloseCb = useCallback(handleClose, [handleClose]);
    const originalHtmlRef = useRef("");
    // Auto-select container on mouseup (after highlighting) and preserve selection
    useEffect(() => {
        if (!isEditing)
            return;
        let isMouseDown = false;
        const onMouseDown = (e) => {
            const target = getEventTarget(e);
            if (isUiElement(target))
                return;
            isMouseDown = true;
        };
        const onMouseUp = () => {
            try {
                if (!isMouseDown)
                    return;
                isMouseDown = false;
                const sel = window.getSelection();
                if (!sel || sel.rangeCount === 0 || sel.isCollapsed)
                    return;
                // Clone selection to restore after we set contentEditable/focus
                const savedRange = sel.getRangeAt(0).cloneRange();
                const node = savedRange.commonAncestorContainer || sel.anchorNode;
                if (!node)
                    return;
                const baseEl = node.nodeType === Node.ELEMENT_NODE
                    ? node
                    : node.parentElement;
                if (!baseEl)
                    return;
                if (isUiElement(baseEl))
                    return;
                const candidate = baseEl.closest("[codepress-data-fp]") ||
                    baseEl.closest("*");
                if (!candidate)
                    return;
                // Allow editing within anchors/buttons; we will prevent their default
                // actions via the click handler while editing mode is active.
                if (stateRef.current.selectedElement !== candidate) {
                    const currentSelected = stateRef.current.selectedElement;
                    if (currentSelected) {
                        currentSelected.style.outline = "";
                        currentSelected.contentEditable =
                            currentSelected.dataset.originalContentEditable ?? "inherit";
                        delete currentSelected.dataset.originalContentEditable;
                    }
                    candidate.style.outline = "2px solid #2563eb";
                    candidate.dataset.originalContentEditable = candidate.contentEditable;
                    candidate.contentEditable = "true";
                    setSelectedElement(candidate);
                    const newElementValues = getElementValues(candidate);
                    setElementValues(newElementValues);
                    const event = new CustomEvent("codepress-select-element", {
                        detail: { element: candidate, initialValues: newElementValues },
                    });
                    document.dispatchEvent(event);
                    originalHtmlRef.current = getCleanElementHTML(candidate, false);
                }
                // Restore selection so partial styling works
                const sel2 = window.getSelection();
                if (sel2) {
                    sel2.removeAllRanges();
                    sel2.addRange(savedRange);
                }
            }
            catch (_) {
                // no-op
            }
        };
        document.addEventListener("mousedown", onMouseDown, true);
        document.addEventListener("mouseup", onMouseUp, true);
        return () => {
            document.removeEventListener("mousedown", onMouseDown, true);
            document.removeEventListener("mouseup", onMouseUp, true);
        };
    }, [isEditing]);
    // Sync highlight/selection when other parts of the UI programmatically select a new element
    useEffect(() => {
        const handleProgrammaticSelect = (e) => {
            const evt = e;
            const element = evt.detail?.element;
            const initialValues = evt.detail?.initialValues;
            if (!element)
                return;
            const currentSelected = stateRef.current.selectedElement;
            if (currentSelected && currentSelected !== element) {
                currentSelected.style.outline = "";
                currentSelected.contentEditable =
                    currentSelected.dataset.originalContentEditable ?? "inherit";
                delete currentSelected.dataset.originalContentEditable;
            }
            element.style.outline = "2px solid #2563eb";
            element.dataset.originalContentEditable = element.contentEditable;
            element.contentEditable = "true";
            setSelectedElement(element);
            if (initialValues)
                setElementValues(initialValues);
        };
        document.addEventListener("codepress-select-element", handleProgrammaticSelect);
        return () => {
            document.removeEventListener("codepress-select-element", handleProgrammaticSelect);
        };
    }, []);
    return (_jsx(GitHubProvider, { children: _jsx(DeploymentProvider, { children: _jsx(RepositoryProvider, { children: _jsx(VisualEditorProvider, { demo: demo, children: _jsxs("div", { "data-codepress-root": "true", ref: setPopoverContainer, children: [_jsx(DeploymentPopover, { isEditing: isEditing }), _jsx(MenuOverlay, { onToggleEditing: handleToggleEditing, isEditing: isEditing }), _jsx(EditorUI, { isDesignPanelOpen: isDesignPanelOpen, setIsDesignPanelOpen: setIsDesignPanelOpen, selectedElement: selectedElement, popoverContainer: popoverContainer, elementValues: elementValues, handleCloseCb: handleCloseCb, handleOpenDesignPanel: handleOpenDesignPanel, isEditing: isEditing })] }) }) }) }) }));
}
