import { j as we } from "./index7.js";
import { logger as i } from "./index12.js";
import { detectRepositoryInfo as J } from "./index29.js";
import { getPreviewLink as X, getBranches as pe, deleteGithubBranch as z } from "./index15.js";
import { createContext as me, useState as l, useRef as T, useCallback as d, useMemo as ve, useEffect as f, useContext as ye } from "react";
import { toast as p } from "./index23.js";
import { BRANCH_PREFIX as be, DeploymentState as C, checkIsDeploying as x, checkIsStaticDeployUrl as Se, checkIsEmptyBranchPrefix as Q } from "./index60.js";
import { isLocalDevNonGithub as ge, checkGithubMode as _ } from "./index26.js";
import { useGitHub as _e } from "./index21.js";
import { captureException as k } from "./index64.js";
const De = 6e4, Ee = 5e3, N = "codepress-current-deploy", W = "staleToast", Pe = "codepress-branch-saves", Le = /* @__PURE__ */ new Set([
  "main",
  "master",
  "develop",
  "dev",
  "development",
  "staging",
  "stage"
]);
function Z() {
  try {
    if (typeof window > "u") return null;
    const s = window.localStorage.getItem(N);
    if (!s) return null;
    const u = JSON.parse(s);
    return !u || typeof u != "object" ? null : u;
  } catch {
    return null;
  }
}
function Be(s) {
  try {
    if (typeof window > "u") return;
    s ? window.localStorage.setItem(N, JSON.stringify(s)) : window.localStorage.removeItem(N);
  } catch {
  }
}
const ee = me(null), Me = ({
  children: s
}) => {
  const { isGitHubMode: u } = _e(), a = J(), [n, te] = l(
    a?.branch || be
  ), [h, re] = l(""), [D, oe] = l(""), [E, m] = l(!1), [v, ne] = l(
    C.UNSAVED
  ), [ie, y] = l([]), [se, O] = l(!1), [P, L] = l(/* @__PURE__ */ new Set()), U = T(""), [ae, V] = l(!1), [ce, M] = l(void 0), B = d((e) => {
    const t = e !== null;
    V(t), M(e ?? void 0), Be(t && e ? { ...e, visible: !0 } : null);
  }, []), b = d(
    (e) => e ? `${Pe}-${e.repository.replace("/", "-")}` : null,
    []
  ), A = d(async (e) => {
    try {
      if (typeof browser < "u" && browser.storage) {
        const r = (await browser.storage.local.get(e))[e] || [];
        return new Set(r);
      }
    } catch (t) {
      i.warn("Unable to load saved branches from storage", t);
    }
    return /* @__PURE__ */ new Set();
  }, []), F = d(
    async (e, t) => {
      try {
        typeof browser < "u" && browser.storage && await browser.storage.local.set({
          [e]: Array.from(t)
        });
      } catch (r) {
        i.warn("Unable to save branches to storage", r);
      }
    },
    []
  ), le = d(
    (e) => {
      const t = J(), r = b(t);
      r && L((c) => {
        const o = new Set(c);
        return o.add(e), F(r, o), o;
      });
    },
    [b, F]
  ), I = d(
    (e) => P.has(e),
    [P]
  ), de = d(
    (e) => ge() ? !1 : Le.has(e) ? !0 : !I(e),
    [I]
  ), q = T(0), K = T(0), G = ve(
    () => x(v) ? Ee : De,
    [v]
  ), S = new URL(window.location.href), g = Se(
    S,
    a?.repository,
    a?.branch
  ), w = d(
    async (e) => {
      if (!_()) {
        i.warn(
          "when not in github mode we does not fetch preview data from github"
        );
        return;
      }
      try {
        const t = ++q.current, r = await X({ branchName: e });
        if (t !== q.current) return null;
        if (!r)
          return k(new Error("Failed to fetch preview data")), i.error("Failed to fetch preview data"), null;
        const c = Z();
        if (g)
          r.state === C.DEPLOYMENT_COMPLETED && x(v) && (i.info(
            "Stale version detected: url is static, but was deployed recently",
            S.origin
          ), m(!0));
        else
          try {
            const o = new URL(r.preview_url).origin;
            e === n && o !== S.origin && (i.info(
              "different preview url",
              o,
              S.origin
            ), m(!0));
          } catch (o) {
            i.warn("Unable to persist popover state", o);
          }
        if (re(r.preview_url ?? ""), oe(r.commit_date ?? ""), ne(r.state), e !== n && (i.info("different branch detected", e, n), m(!0)), e !== a?.branch && (i.info("different repo branch detected", e, a?.branch), m(!0)), c?.visible && c.commit_hash === r.commit_hash && B({ ...r, branch_name: e }), c?.visible && !x(r.state) && c.branch_name !== e) {
          const o = await X({
            branchName: c.branch_name
          });
          o.state === C.DEPLOYMENT_COMPLETED && o.preview_url && p.error("Stale Version", {
            id: "other-branch-deployed",
            description: "The version you are looking at is a different branch from where you saved.",
            action: {
              label: "Load Newest Version",
              onClick: () => {
                window.location.href = o.preview_url;
              }
            },
            duration: 1 / 0
          }), B({
            ...o,
            branch_name: c.branch_name
          });
        }
        return y((o) => {
          const R = o.findIndex((he) => he.name === e), j = {
            name: e,
            preview_url: r.preview_url ?? "",
            commit_date: r.commit_date ?? "",
            state: r.state
          };
          if (R === -1)
            return [...o, j];
          const $ = o.slice();
          return $[R] = { ...o[R], ...j }, $;
        }), r;
      } catch (t) {
        k(t), i.error("Preview fetch failed:", t);
      }
      return null;
    },
    [n]
  );
  f(() => {
    _() || E && h && (a?.branch === n ? p.warning("Stale Version", {
      id: W,
      description: "The version you are looking at might not be up to date.",
      action: {
        label: g ? "Refresh" : "Load Newest Version",
        onClick: () => {
          g ? window.location.reload() : window.location.href = h;
        }
      },
      duration: 1 / 0
    }) : p.error("Stale Version", {
      id: W,
      description: "The version you are looking at is a different branch from what you selected.",
      action: {
        label: "Load Newest Version",
        onClick: () => {
          window.location.href = h;
        }
      },
      duration: 1 / 0
    }));
  }, [E, h, n]);
  const H = d(async () => {
    if (!_()) {
      i.warn(
        "when not in github mode we does not fetch branches from github"
      );
      return;
    }
    try {
      O(!0);
      const e = ++K.current, t = await pe();
      if (e !== K.current) return;
      if (!t) throw new Error("Failed to fetch branches data");
      y(t.branches);
    } catch (e) {
      k(e), i.error("Branches fetch failed:", e);
    } finally {
      O(!1);
    }
  }, []), Y = d(
    async (e) => {
      const t = () => p.error("Branch Deletion", {
        id: `branch-delete-${e}`,
        description: "Could not delete your branch.",
        action: {
          label: "Try Again",
          onClick: () => Y(e)
        },
        duration: 1 / 0
      });
      try {
        const { success: r } = await z({ branchName: e });
        if (!r) {
          t();
          return;
        }
        y(
          (c) => c.filter((o) => o.name !== e)
        ), p.success("Branch deleted", {
          id: `branch-delete-${e}`,
          duration: 1500
          // 1.5 seconds millis
        });
      } catch {
        t();
      }
    },
    [z, y]
  );
  f(() => {
    const e = a ? a.repository : "";
    if (e !== U.current)
      if (U.current = e, a) {
        const t = b(a);
        t && A(t).then(L);
      } else
        L(/* @__PURE__ */ new Set());
  }, [b, A]), f(() => {
    const e = Z();
    e?.visible && e.commit_hash && (V(!0), M(e));
  }, []), f(() => {
    _() && H();
  }, [u]), f(() => {
    if (Q(n))
      return;
    w(n);
    const e = window.setInterval(
      () => w(n),
      G
    );
    return () => window.clearInterval(e);
  }, [n, G, w]), f(() => {
    const e = () => {
      Q(n) || w(n);
    };
    return window.addEventListener("focus", e), () => window.removeEventListener("focus", e);
  }, [n, w, u]);
  const ue = D ? new Intl.DateTimeFormat(void 0, {
    dateStyle: "medium",
    timeStyle: "short"
  }).format(new Date(D)) : "â€”", fe = {
    branchName: n,
    setBranchName: te,
    previewUrl: h,
    lastSaved: D,
    lastUpdatedText: ue,
    currentDeployment: v,
    branches: ie,
    fetchBranches: H,
    isBranchesLoading: se,
    deleteBranch: Y,
    showDeploymentPopover: ae,
    setShowDeploymentPopover: B,
    deploymentPopover: ce,
    viewingStaleVersion: E,
    isStaticDeployUrl: g,
    // Branch save history
    savedBranches: P,
    addSavedBranch: le,
    hasSavedToBranch: I,
    shouldShowSaveDialog: de
  };
  return /* @__PURE__ */ we.jsx(ee.Provider, { value: fe, children: s });
}, Ae = () => {
  const s = ye(ee);
  if (!s)
    throw new Error("useDeployment must be used within a DeploymentProvider");
  return s;
};
export {
  Me as DeploymentProvider,
  Ee as POLL_MS_DEPLOY,
  De as POLL_MS_IDLE,
  Ae as useDeployment
};
