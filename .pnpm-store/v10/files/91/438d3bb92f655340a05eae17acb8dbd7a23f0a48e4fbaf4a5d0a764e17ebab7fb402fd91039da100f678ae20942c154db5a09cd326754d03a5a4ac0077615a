class D {
  options;
  isDragging = !1;
  isLongPressActive = !1;
  longPressTimer = null;
  longPressStartPos = { x: 0, y: 0 };
  longPressElement = null;
  draggedElement = null;
  ghostElement = null;
  dropIndicator = null;
  currentDropContainer = null;
  dragStartPos = { x: 0, y: 0 };
  currentDropTarget = null;
  currentDropPosition = "inside";
  constructor(e = {}) {
    this.options = {
      onDropElement: e.onDropElement || (() => {
      }),
      dropZoneColor: e.dropZoneColor || "#2563eb",
      ghostOpacity: e.ghostOpacity || 0.6,
      longPressDuration: e.longPressDuration || 500,
      movementThreshold: e.movementThreshold || 5
    }, this.init();
  }
  init() {
    this.createStyles(), this.bindGlobalEvents();
  }
  createStyles() {
    const e = "simple-drag-drop-styles";
    if (document.getElementById(e)) return;
    const i = `
      .simple-long-press-active {
        cursor: grabbing !important;
        background: rgba(37, 99, 235, 0.1) !important;
        outline: 2px solid ${this.options.dropZoneColor} !important;
        outline-offset: 1px !important;
        box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.2) !important;
        transition: all 0.2s ease !important;
        position: relative !important;
      }
      
      .simple-long-press-active::after {
        content: "Drag mode activated - move to drag";
        position: absolute;
        top: -40px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.9);
        color: white;
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 12px;
        white-space: nowrap;
        pointer-events: none;
        z-index: 1000000;
        animation: simple-tooltip-appear 0.2s ease;
      }
      
      @keyframes simple-tooltip-appear {
        from { opacity: 0; transform: translateX(-50%) translateY(5px); }
        to { opacity: 1; transform: translateX(-50%) translateY(0); }
      }
      
      .simple-ghost-element {
        position: absolute;
        opacity: ${this.options.ghostOpacity};
        pointer-events: none;
        z-index: 1000000;
        border: 2px dashed ${this.options.dropZoneColor};
        background: rgba(37, 99, 235, 0.1);
        border-radius: 4px;
        transform: rotate(2deg);
      }
      
      .simple-drop-indicator {
        position: absolute;
        background: ${this.options.dropZoneColor};
        pointer-events: none;
        z-index: 999998;
        border-radius: 2px;
        box-shadow: 0 0 0 1px rgba(255,255,255,0.8), 0 2px 4px rgba(0,0,0,0.2);
        transition: all 0.1s ease;
      }
      
      .simple-drop-indicator.horizontal {
        height: 2px;
        min-width: 20px;
      }
      
      .simple-drop-indicator.vertical {
        width: 4px;
        min-height: 40px;
      }
      
      .simple-drop-target-highlight {
        outline: 2px solid ${this.options.dropZoneColor} !important;
        outline-offset: 2px !important;
        background: rgba(37, 99, 235, 0.05) !important;
      }
      
      .simple-drop-container-highlight {
        background: rgba(37, 99, 235, 0.08) !important;
        outline: 2px dashed ${this.options.dropZoneColor} !important;
        outline-offset: 4px !important;
        border-radius: 8px !important;
        transition: all 0.3s ease !important;
        position: relative !important;
      }
      
      .simple-drop-container-highlight::before {
        content: "Drop Container";
        position: absolute !important;
        top: -8px !important;
        left: 8px !important;
        background: ${this.options.dropZoneColor} !important;
        color: white !important;
        padding: 2px 8px !important;
        border-radius: 4px !important;
        font-size: 11px !important;
        font-weight: 600 !important;
        font-family: system-ui, -apple-system, sans-serif !important;
        z-index: 999999 !important;
        pointer-events: none !important;
        text-transform: uppercase !important;
        letter-spacing: 0.5px !important;
      }
      
      .simple-dragging-source {
        opacity: 0.3 !important;
        transition: opacity 0.2s ease !important;
      }
      
      body.simple-dragging {
        cursor: grabbing !important;
        user-select: none !important;
        -webkit-user-select: none !important;
      }
      
      body.simple-dragging * {
        pointer-events: none !important;
      }
    `, t = document.createElement("style");
    t.id = e, t.textContent = i, document.head.appendChild(t);
  }
  bindGlobalEvents() {
    document.addEventListener("mousemove", this.handleMouseMove), document.addEventListener("mouseup", this.handleMouseUp), document.addEventListener("mousedown", this.handleMouseDown);
  }
  enableDragOnElement(e) {
  }
  disableDragOnElement(e) {
    this.longPressElement === e && this.cancelLongPress(), e.classList.remove("simple-long-press-active");
  }
  startLongPress(e, i) {
    this.cancelLongPress(), this.longPressElement = e, this.longPressStartPos = { x: i.clientX, y: i.clientY }, this.isLongPressActive = !1, this.longPressTimer = window.setTimeout(() => {
      this.longPressElement === e && this.activateLongPress();
    }, this.options.longPressDuration);
  }
  cancelLongPress() {
    this.longPressTimer && (clearTimeout(this.longPressTimer), this.longPressTimer = null), this.longPressElement && this.longPressElement.classList.remove("simple-long-press-active"), this.longPressElement = null, this.isLongPressActive = !1;
  }
  activateLongPress() {
    this.longPressElement && (this.isLongPressActive = !0, this.longPressElement.classList.add("simple-long-press-active"), navigator.vibrate && navigator.vibrate(50));
  }
  checkLongPressMovement(e) {
    if (!this.longPressElement || this.isLongPressActive) return !1;
    const i = Math.abs(e.clientX - this.longPressStartPos.x), t = Math.abs(e.clientY - this.longPressStartPos.y);
    return Math.sqrt(i * i + t * t) > this.options.movementThreshold ? (this.cancelLongPress(), !0) : !1;
  }
  getElementId(e) {
    return e.getAttribute("codepress-data-fp") || `element-${Date.now()}`;
  }
  handleMouseDown = (e) => {
    const i = e.target;
    if (this.isDragging || this.isUiElement(i))
      return;
    const t = this.findDraggableElement(i);
    t && this.startLongPress(t, e);
  };
  findDraggableElement(e) {
    let i = e, t = 0;
    for (; i && i !== document.body && t < 10; ) {
      if (this.isUiElement(i)) {
        i = i.parentElement, t++;
        continue;
      }
      if (i.tagName && i.tagName !== "HTML" && i.tagName !== "HEAD" && i.tagName !== "SCRIPT" && i.tagName !== "STYLE" && i.tagName !== "META" && i.tagName !== "LINK")
        return i;
      i = i.parentElement, t++;
    }
    return null;
  }
  isUiElement(e) {
    return !!(e.closest("[data-codepress-root], [data-codepress-portal]") || e.classList.contains("simple-long-press-active") || e.classList.contains("simple-ghost-element") || e.classList.contains("simple-drop-indicator"));
  }
  startDragging(e, i) {
    this.isDragging = !0, this.draggedElement = e, this.dragStartPos = { x: i.clientX, y: i.clientY }, document.body.classList.add("simple-dragging"), e.classList.add("simple-dragging-source"), this.createGhostElement(e, i);
  }
  handleMouseMove = (e) => {
    if (!(this.longPressElement && !this.isLongPressActive && this.checkLongPressMovement(e))) {
      if (this.isDragging && this.ghostElement && this.draggedElement) {
        const i = this.draggedElement.getBoundingClientRect();
        this.ghostElement.style.left = `${e.pageX - i.width / 2}px`, this.ghostElement.style.top = `${e.pageY - i.height / 2}px`, this.updateDropTarget(e);
      }
      this.isLongPressActive && !this.isDragging && this.longPressElement && (this.startDragging(this.longPressElement, e), this.cancelLongPress());
    }
  };
  handleMouseUp = (e) => {
    this.isDragging && (this.currentDropTarget && this.performDrop(), this.cleanup()), this.longPressElement && !this.isDragging && this.cancelLongPress();
  };
  createGhostElement(e, i) {
    const t = e.getBoundingClientRect();
    this.ghostElement = e.cloneNode(!0), this.ghostElement.className += " simple-ghost-element", this.ghostElement.style.width = `${t.width}px`, this.ghostElement.style.height = `${t.height}px`, this.ghostElement.style.left = `${i.pageX - t.width / 2}px`, this.ghostElement.style.top = `${i.pageY - t.height / 2}px`, this.ghostElement.querySelectorAll(
      ".simple-drag-handle"
    ).forEach((n) => n.remove()), document.body.appendChild(this.ghostElement);
  }
  updateDropTarget(e) {
    document.body.classList.remove("simple-dragging"), this.ghostElement && (this.ghostElement.style.display = "none");
    const i = document.elementFromPoint(
      e.clientX,
      e.clientY
    );
    this.ghostElement && (this.ghostElement.style.display = "block"), document.body.classList.add("simple-dragging");
    const t = this.findValidDropTarget(i, e);
    t && t !== this.draggedElement ? t !== this.currentDropTarget && (this.currentDropTarget = t, this.showDropIndicator(t, e)) : (this.clearDropIndicator(), this.currentDropTarget = null, this.currentDropContainer = null);
  }
  findValidDropTarget(e, i) {
    if (!e)
      return null;
    let t = e, s = 0;
    for (; t && t !== document.body && s < 20; ) {
      if (t === this.draggedElement || this.draggedElement && this.draggedElement.contains(t)) {
        t = t.parentElement, s++;
        continue;
      }
      if (this.isUiElement(t)) {
        t = t.parentElement, s++;
        continue;
      }
      if (this.isFlexOrGridContainer(t) && t.children.length > 0) {
        const n = this.findNearestChild(t, i);
        if (n && n !== this.draggedElement)
          return n;
      }
      if (t.tagName && t.tagName !== "HTML" && t.tagName !== "HEAD" && t.tagName !== "SCRIPT" && t.tagName !== "STYLE" && t.tagName !== "META" && t.tagName !== "LINK")
        return t;
      t = t.parentElement, s++;
    }
    return null;
  }
  findNearestChild(e, i) {
    const t = Array.from(e.children).filter(
      (o) => o instanceof HTMLElement && o !== this.draggedElement && !this.draggedElement?.contains(o)
    );
    if (t.length === 0)
      return null;
    let s = null, n = 1 / 0;
    return t.forEach((o) => {
      const r = o.getBoundingClientRect(), c = r.left + r.width / 2, g = r.top + r.height / 2, a = Math.sqrt(
        Math.pow(i.clientX - c, 2) + Math.pow(i.clientY - g, 2)
      );
      a < n && (n = a, s = o);
    }), s;
  }
  showDropIndicator(e, i) {
    this.clearDropIndicator();
    const t = e.getBoundingClientRect(), s = window.pageYOffset || document.documentElement.scrollTop, n = window.pageXOffset || document.documentElement.scrollLeft, o = e.parentElement, r = this.isFlexOrGridContainer(o), c = this.isInlineElement(e), g = this.isGridItem(e, o), a = this.isFlexItem(e, o), h = i.clientX - t.left, l = i.clientY - t.top, d = r && this.shouldUseHorizontalDropping(o) || c || g || a, p = d ? Math.max(t.width * 0.4, 60) : t.width * 0.25, m = d ? t.height * 0.2 : t.height * 0.25;
    if (d) {
      const u = h < p, f = h > t.width - p, E = l < m, y = l > t.height - m;
      u ? this.currentDropPosition = "left" : f ? this.currentDropPosition = "right" : E && !u && !f ? this.currentDropPosition = "before" : y && !u && !f ? this.currentDropPosition = "after" : this.currentDropPosition = "inside";
    } else
      l < m ? this.currentDropPosition = "before" : l > t.height - m ? this.currentDropPosition = "after" : this.currentDropPosition = "inside";
    this.highlightDropContainer(e), this.createDropIndicator(e, t, s, n);
  }
  isFlexOrGridContainer(e) {
    if (!e) return !1;
    const t = window.getComputedStyle(e).display;
    return t === "flex" || t === "inline-flex" || t === "grid" || t === "inline-grid";
  }
  isInlineElement(e) {
    const t = window.getComputedStyle(e).display, s = t === "inline" || t === "inline-block" || t === "inline-flex" || t === "inline-grid", o = [
      "SPAN",
      "A",
      "EM",
      "STRONG",
      "B",
      "I",
      "U",
      "CODE",
      "SMALL",
      "SUB",
      "SUP",
      "MARK",
      "TIME",
      "KBD",
      "SAMP",
      "VAR"
    ].includes(e.tagName);
    return s || o;
  }
  isGridItem(e, i) {
    if (!i) return !1;
    const t = window.getComputedStyle(i), s = t.display === "grid" || t.display === "inline-grid";
    if (!s) return !1;
    const n = t.gridTemplateColumns, o = t.gridAutoFlow || "row", r = n !== "none" && n !== "1fr" && (n.includes(" ") || n.includes("fr"));
    return s && r && (o === "row" || o === "row dense");
  }
  isFlexItem(e, i) {
    if (!i) return !1;
    const t = window.getComputedStyle(i), s = t.display === "flex" || t.display === "inline-flex";
    if (!s) return !1;
    const n = t.flexDirection || "row";
    return s && (n === "row" || n === "row-reverse");
  }
  shouldUseHorizontalDropping(e) {
    if (!e) return !1;
    const i = window.getComputedStyle(e);
    if (i.display === "flex" || i.display === "inline-flex") {
      const t = i.flexDirection || "row";
      return t === "row" || t === "row-reverse";
    }
    if (i.display === "grid" || i.display === "inline-grid") {
      const t = i.gridTemplateColumns, s = i.gridAutoFlow || "row";
      return t !== "none" && t !== "1fr" && (t.includes(" ") || t.includes("fr")) && (s === "row" || s === "row dense");
    }
    return !1;
  }
  highlightDropContainer(e) {
    this.currentDropContainer && this.currentDropContainer.classList.remove(
      "simple-drop-container-highlight"
    );
    let i = null;
    switch (this.currentDropPosition) {
      case "inside":
        i = e;
        break;
      case "before":
      case "after":
      case "left":
      case "right":
        i = e.parentElement;
        break;
    }
    i && i !== this.draggedElement ? (i.classList.add("simple-drop-container-highlight"), this.currentDropContainer = i) : this.currentDropContainer = null;
  }
  createDropIndicator(e, i, t, s) {
    switch (this.currentDropPosition) {
      case "before":
        this.dropIndicator = this.createHorizontalIndicator(
          i.left + s,
          i.top + t - 1,
          i.width,
          "BEFORE"
        );
        break;
      case "after":
        this.dropIndicator = this.createHorizontalIndicator(
          i.left + s,
          i.bottom + t - 1,
          i.width,
          "AFTER"
        );
        break;
      case "left":
        const n = e.parentElement;
        n && this.isFlexOrGridContainer(n) ? this.dropIndicator = this.createSiblingIndicator(
          e,
          "left",
          t,
          s
        ) : this.dropIndicator = this.createVerticalIndicator(
          i.left + s - 3,
          i.top + t - 10,
          i.height + 20,
          "LEFT"
        );
        break;
      case "right":
        const r = e.parentElement;
        r && this.isFlexOrGridContainer(r) ? this.dropIndicator = this.createSiblingIndicator(
          e,
          "right",
          t,
          s
        ) : this.dropIndicator = this.createVerticalIndicator(
          i.right + s - 1,
          i.top + t - 10,
          i.height + 20,
          "RIGHT"
        );
        break;
      case "inside":
        e.classList.add("simple-drop-target-highlight");
        return;
    }
    this.dropIndicator && document.body.appendChild(this.dropIndicator);
  }
  createHorizontalIndicator(e, i, t, s) {
    const n = document.createElement("div");
    return n.className = "simple-drop-indicator horizontal", n.style.left = `${e}px`, n.style.top = `${i}px`, n.style.width = `${t}px`, n;
  }
  createVerticalIndicator(e, i, t, s) {
    const n = document.createElement("div");
    return n.className = "simple-drop-indicator vertical", n.style.left = `${e}px`, n.style.top = `${i}px`, n.style.height = `${t}px`, n;
  }
  createSiblingIndicator(e, i, t, s) {
    const n = e.parentElement;
    if (!n) return null;
    const o = Array.from(n.children).filter(
      (h) => h !== this.draggedElement && h instanceof HTMLElement
    ), r = o.indexOf(e);
    if (r === -1) return null;
    let c, g;
    if (i === "left")
      if (r === 0)
        c = e, g = "before";
      else {
        const h = o[r - 1], l = e.getBoundingClientRect(), d = h.getBoundingClientRect(), p = (d.right + l.left) / 2;
        return this.createVerticalIndicator(
          p + s - 2,
          Math.min(d.top, l.top) + t - 10,
          Math.max(d.height, l.height) + 20,
          "BETWEEN"
        );
      }
    else if (r === o.length - 1)
      c = e, g = "after";
    else {
      const h = o[r + 1], l = e.getBoundingClientRect(), d = h.getBoundingClientRect(), p = (l.right + d.left) / 2;
      return this.createVerticalIndicator(
        p + s - 2,
        Math.min(l.top, d.top) + t - 10,
        Math.max(l.height, d.height) + 20,
        "BETWEEN"
      );
    }
    const a = c.getBoundingClientRect();
    return g === "before" ? this.createVerticalIndicator(
      a.left + s - 3,
      a.top + t - 10,
      a.height + 20,
      "LEFT"
    ) : this.createVerticalIndicator(
      a.right + s - 1,
      a.top + t - 10,
      a.height + 20,
      "RIGHT"
    );
  }
  clearDropIndicator() {
    this.dropIndicator && (this.dropIndicator.remove(), this.dropIndicator = null), document.querySelectorAll(".simple-drop-target-highlight").forEach((e) => {
      e.classList.remove("simple-drop-target-highlight");
    }), document.querySelectorAll(".simple-drop-container-highlight").forEach((e) => {
      e.classList.remove("simple-drop-container-highlight");
    });
  }
  performDrop() {
    if (!this.currentDropTarget || !this.draggedElement) return;
    const e = {
      source: {
        element: this.draggedElement,
        location: this.draggedElement.getAttribute("codepress-data-fp"),
        tagName: this.draggedElement.tagName
      },
      target: {
        element: this.currentDropTarget,
        location: this.currentDropTarget.getAttribute("codepress-data-fp"),
        tagName: this.currentDropTarget.tagName
      },
      position: this.currentDropPosition
    };
    this.options.onDropElement(e);
  }
  cleanup() {
    this.isDragging = !1, this.ghostElement && (this.ghostElement.remove(), this.ghostElement = null), this.clearDropIndicator(), document.body.classList.remove("simple-dragging"), this.draggedElement && (this.draggedElement.classList.remove("simple-dragging-source"), this.draggedElement.classList.remove("simple-long-press-active")), this.draggedElement = null, this.currentDropTarget = null, this.currentDropPosition = "inside", this.currentDropContainer = null;
  }
  destroy() {
    this.cleanup(), this.cancelLongPress(), document.removeEventListener("mousemove", this.handleMouseMove), document.removeEventListener("mouseup", this.handleMouseUp), document.removeEventListener("mousedown", this.handleMouseDown), document.querySelectorAll(".simple-long-press-active").forEach((i) => {
      i.classList.remove("simple-long-press-active");
    });
    const e = document.getElementById("simple-drag-drop-styles");
    e && e.remove();
  }
}
export {
  D as SimpleDragDrop
};
