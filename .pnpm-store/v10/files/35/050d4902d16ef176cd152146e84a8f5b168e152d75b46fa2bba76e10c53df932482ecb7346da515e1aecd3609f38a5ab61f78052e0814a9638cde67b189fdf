import { getEnvelopeEndpointWithUrlEncodedAuth as F } from "./index212.js";
import { DEFAULT_ENVIRONMENT as L } from "./index191.js";
import { getTraceContextFromScope as j, getCurrentScope as U, getIsolationScope as W } from "./index120.js";
import { DEBUG_BUILD as l } from "./index208.js";
import { createEventEnvelope as J, createSessionEnvelope as V } from "./index197.js";
import { setupIntegration as Y, afterSetupIntegrations as D, setupIntegrations as G } from "./index144.js";
import { updateSession as O } from "./index199.js";
import { getDynamicSamplingContextFromScope as z } from "./index190.js";
import { createClientReportEnvelope as q } from "./index213.js";
import { debug as p } from "./index151.js";
import { makeDsn as H, dsnToString as K } from "./index194.js";
import { addItemToEnvelope as Q, createAttachmentEnvelopeItem as X } from "./index198.js";
import { getPossibleEventMessages as Z } from "./index214.js";
import { isPrimitive as tt, isParameterizedString as et, isThenable as nt, isPlainObject as k } from "./index132.js";
import { merge as st } from "./index209.js";
import { uuid4 as S, checkOrSetAlreadyCaught as w } from "./index121.js";
import { parseSampleRate as rt } from "./index215.js";
import { prepareEvent as ot } from "./index200.js";
import { showSpanDropWarning as N } from "./index196.js";
import { resolvedSyncPromise as x, SyncPromise as it, rejectedSyncPromise as at } from "./index130.js";
import { convertTransactionEventToSpanJson as ct, convertSpanJsonToTransactionEvent as pt } from "./index216.js";
const R = "Not capturing exception because it's already been captured.", T = "Discarded session because of missing or non-string release", A = Symbol.for("SentryInternalError"), $ = Symbol.for("SentryDoNotSendEventError");
function g(i) {
  return {
    message: i,
    [A]: !0
  };
}
function I(i) {
  return {
    message: i,
    [$]: !0
  };
}
function C(i) {
  return !!i && typeof i == "object" && A in i;
}
function M(i) {
  return !!i && typeof i == "object" && $ in i;
}
class Ct {
  /** Options passed to the SDK. */
  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
  /** Array of set up integrations. */
  /** Number of calls being processed */
  /** Holds flushable  */
  // eslint-disable-next-line @typescript-eslint/ban-types
  /**
   * Initializes this client instance.
   *
   * @param options Options for the client.
   */
  constructor(t) {
    if (this._options = t, this._integrations = {}, this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], t.dsn ? this._dsn = H(t.dsn) : l && p.warn("No DSN provided, client will not send events."), this._dsn) {
      const e = F(
        this._dsn,
        t.tunnel,
        t._metadata ? t._metadata.sdk : void 0
      );
      this._transport = t.transport({
        tunnel: this._options.tunnel,
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...t.transportOptions,
        url: e
      });
    }
  }
  /**
   * Captures an exception event and sends it to Sentry.
   *
   * Unlike `captureException` exported from every SDK, this method requires that you pass it the current scope.
   */
  captureException(t, e, n) {
    const r = S();
    if (w(t))
      return l && p.log(R), r;
    const s = {
      event_id: r,
      ...e
    };
    return this._process(
      this.eventFromException(t, s).then(
        (c) => this._captureEvent(c, s, n)
      )
    ), s.event_id;
  }
  /**
   * Captures a message event and sends it to Sentry.
   *
   * Unlike `captureMessage` exported from every SDK, this method requires that you pass it the current scope.
   */
  captureMessage(t, e, n, r) {
    const s = {
      event_id: S(),
      ...n
    }, c = et(t) ? t : String(t), o = tt(t) ? this.eventFromMessage(c, e, s) : this.eventFromException(t, s);
    return this._process(o.then((d) => this._captureEvent(d, s, r))), s.event_id;
  }
  /**
   * Captures a manually created event and sends it to Sentry.
   *
   * Unlike `captureEvent` exported from every SDK, this method requires that you pass it the current scope.
   */
  captureEvent(t, e, n) {
    const r = S();
    if (e?.originalException && w(e.originalException))
      return l && p.log(R), r;
    const s = {
      event_id: r,
      ...e
    }, c = t.sdkProcessingMetadata || {}, o = c.capturedSpanScope, d = c.capturedSpanIsolationScope;
    return this._process(
      this._captureEvent(t, s, o || n, d)
    ), s.event_id;
  }
  /**
   * Captures a session.
   */
  captureSession(t) {
    this.sendSession(t), O(t, { init: !1 });
  }
  /**
   * Create a cron monitor check in and send it to Sentry. This method is not available on all clients.
   *
   * @param checkIn An object that describes a check in.
   * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want
   * to create a monitor automatically when sending a check in.
   * @param scope An optional scope containing event metadata.
   * @returns A string representing the id of the check in.
   */
  /**
   * Get the current Dsn.
   */
  getDsn() {
    return this._dsn;
  }
  /**
   * Get the current options.
   */
  getOptions() {
    return this._options;
  }
  /**
   * Get the SDK metadata.
   * @see SdkMetadata
   */
  getSdkMetadata() {
    return this._options._metadata;
  }
  /**
   * Returns the transport that is used by the client.
   * Please note that the transport gets lazy initialized so it will only be there once the first event has been sent.
   */
  getTransport() {
    return this._transport;
  }
  /**
   * Wait for all events to be sent or the timeout to expire, whichever comes first.
   *
   * @param timeout Maximum time in ms the client should wait for events to be flushed. Omitting this parameter will
   *   cause the client to wait until all events are sent before resolving the promise.
   * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are
   * still events in the queue when the timeout is reached.
   */
  flush(t) {
    const e = this._transport;
    return e ? (this.emit("flush"), this._isClientDoneProcessing(t).then((n) => e.flush(t).then((r) => n && r))) : x(!0);
  }
  /**
   * Flush the event queue and set the client to `enabled = false`. See {@link Client.flush}.
   *
   * @param {number} timeout Maximum time in ms the client should wait before shutting down. Omitting this parameter will cause
   *   the client to wait until all events are sent before disabling itself.
   * @returns {Promise<boolean>} A promise which resolves to `true` if the flush completes successfully before the timeout, or `false` if
   * it doesn't.
   */
  close(t) {
    return this.flush(t).then((e) => (this.getOptions().enabled = !1, this.emit("close"), e));
  }
  /**
   * Get all installed event processors.
   */
  getEventProcessors() {
    return this._eventProcessors;
  }
  /**
   * Adds an event processor that applies to any event processed by this client.
   */
  addEventProcessor(t) {
    this._eventProcessors.push(t);
  }
  /**
   * Initialize this client.
   * Call this after the client was set on a scope.
   */
  init() {
    (this._isEnabled() || // Force integrations to be setup even if no DSN was set when we have
    // Spotlight enabled. This is particularly important for browser as we
    // don't support the `spotlight` option there and rely on the users
    // adding the `spotlightBrowserIntegration()` to their integrations which
    // wouldn't get initialized with the check below when there's no DSN set.
    this._options.integrations.some(({ name: t }) => t.startsWith("Spotlight"))) && this._setupIntegrations();
  }
  /**
   * Gets an installed integration by its name.
   *
   * @returns {Integration|undefined} The installed integration or `undefined` if no integration with that `name` was installed.
   */
  getIntegrationByName(t) {
    return this._integrations[t];
  }
  /**
   * Add an integration to the client.
   * This can be used to e.g. lazy load integrations.
   * In most cases, this should not be necessary,
   * and you're better off just passing the integrations via `integrations: []` at initialization time.
   * However, if you find the need to conditionally load & add an integration, you can use `addIntegration` to do so.
   */
  addIntegration(t) {
    const e = this._integrations[t.name];
    Y(this, t, this._integrations), e || D(this, [t]);
  }
  /**
   * Send a fully prepared event to Sentry.
   */
  sendEvent(t, e = {}) {
    this.emit("beforeSendEvent", t, e);
    let n = J(t, this._dsn, this._options._metadata, this._options.tunnel);
    for (const s of e.attachments || [])
      n = Q(n, X(s));
    const r = this.sendEnvelope(n);
    r && r.then((s) => this.emit("afterSendEvent", t, s), null);
  }
  /**
   * Send a session or session aggregrates to Sentry.
   */
  sendSession(t) {
    const { release: e, environment: n = L } = this._options;
    if ("aggregates" in t) {
      const s = t.attrs || {};
      if (!s.release && !e) {
        l && p.warn(T);
        return;
      }
      s.release = s.release || e, s.environment = s.environment || n, t.attrs = s;
    } else {
      if (!t.release && !e) {
        l && p.warn(T);
        return;
      }
      t.release = t.release || e, t.environment = t.environment || n;
    }
    this.emit("beforeSendSession", t);
    const r = V(t, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(r);
  }
  /**
   * Record on the client that an event got dropped (ie, an event that will not be sent to Sentry).
   */
  recordDroppedEvent(t, e, n = 1) {
    if (this._options.sendClientReports) {
      const r = `${t}:${e}`;
      l && p.log(`Recording outcome: "${r}"${n > 1 ? ` (${n} times)` : ""}`), this._outcomes[r] = (this._outcomes[r] || 0) + n;
    }
  }
  /* eslint-disable @typescript-eslint/unified-signatures */
  /**
   * Register a callback for whenever a span is started.
   * Receives the span as argument.
   * @returns {() => void} A function that, when executed, removes the registered callback.
   */
  /**
   * Register a hook on this client.
   */
  on(t, e) {
    const n = this._hooks[t] = this._hooks[t] || [];
    return n.push(e), () => {
      const r = n.indexOf(e);
      r > -1 && n.splice(r, 1);
    };
  }
  /** Fire a hook whenever a span starts. */
  /**
   * Emit a hook that was previously registered via `on()`.
   */
  emit(t, ...e) {
    const n = this._hooks[t];
    n && n.forEach((r) => r(...e));
  }
  /**
   * Send an envelope to Sentry.
   */
  sendEnvelope(t) {
    return this.emit("beforeEnvelope", t), this._isEnabled() && this._transport ? this._transport.send(t).then(null, (e) => (l && p.error("Error while sending envelope:", e), e)) : (l && p.error("Transport disabled"), x({}));
  }
  /* eslint-enable @typescript-eslint/unified-signatures */
  /** Setup integrations for this client. */
  _setupIntegrations() {
    const { integrations: t } = this._options;
    this._integrations = G(this, t), D(this, t);
  }
  /** Updates existing session based on the provided event */
  _updateSessionFromEvent(t, e) {
    let n = e.level === "fatal", r = !1;
    const s = e.exception?.values;
    if (s) {
      r = !0;
      for (const d of s)
        if (d.mechanism?.handled === !1) {
          n = !0;
          break;
        }
    }
    const c = t.status === "ok";
    (c && t.errors === 0 || c && n) && (O(t, {
      ...n && { status: "crashed" },
      errors: t.errors || Number(r || n)
    }), this.captureSession(t));
  }
  /**
   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
   * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
   *
   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
   * `true`.
   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
   * `false` otherwise
   */
  _isClientDoneProcessing(t) {
    return new it((e) => {
      let n = 0;
      const r = 1, s = setInterval(() => {
        this._numProcessing == 0 ? (clearInterval(s), e(!0)) : (n += r, t && n >= t && (clearInterval(s), e(!1)));
      }, r);
    });
  }
  /** Determines whether this SDK is enabled and a transport is present. */
  _isEnabled() {
    return this.getOptions().enabled !== !1 && this._transport !== void 0;
  }
  /**
   * Adds common information to events.
   *
   * The information includes release and environment from `options`,
   * breadcrumbs and context (extra, tags and user) from the scope.
   *
   * Information that is already present in the event is never overwritten. For
   * nested objects, such as the context, keys are merged.
   *
   * @param event The original event.
   * @param hint May contain additional information about the original exception.
   * @param currentScope A scope containing event metadata.
   * @returns A new event with more information.
   */
  _prepareEvent(t, e, n, r) {
    const s = this.getOptions(), c = Object.keys(this._integrations);
    return !e.integrations && c?.length && (e.integrations = c), this.emit("preprocessEvent", t, e), t.type || r.setLastEventId(t.event_id || e.event_id), ot(s, t, e, n, this, r).then((o) => {
      if (o === null)
        return o;
      this.emit("postprocessEvent", o, e), o.contexts = {
        trace: j(n),
        ...o.contexts
      };
      const d = z(this, n);
      return o.sdkProcessingMetadata = {
        dynamicSamplingContext: d,
        ...o.sdkProcessingMetadata
      }, o;
    });
  }
  /**
   * Processes the event and logs an error in case of rejection
   * @param event
   * @param hint
   * @param scope
   */
  _captureEvent(t, e = {}, n = U(), r = W()) {
    return l && b(t) && p.log(`Captured error event \`${Z(t)[0] || "<unknown>"}\``), this._processEvent(t, e, n, r).then(
      (s) => s.event_id,
      (s) => {
        l && (M(s) ? p.log(s.message) : C(s) ? p.warn(s.message) : p.warn(s));
      }
    );
  }
  /**
   * Processes an event (either error or message) and sends it to Sentry.
   *
   * This also adds breadcrumbs and context information to the event. However,
   * platform specific meta data (such as the User's IP address) must be added
   * by the SDK implementor.
   *
   *
   * @param event The event to send to Sentry.
   * @param hint May contain additional information about the original exception.
   * @param currentScope A scope containing event metadata.
   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
   */
  _processEvent(t, e, n, r) {
    const s = this.getOptions(), { sampleRate: c } = s, o = B(t), d = b(t), u = t.type || "error", h = `before send for type \`${u}\``, m = typeof c > "u" ? void 0 : rt(c);
    if (d && typeof m == "number" && Math.random() > m)
      return this.recordDroppedEvent("sample_rate", "error"), at(
        I(
          `Discarding event because it's not included in the random sample (sampling rate = ${c})`
        )
      );
    const y = u === "replay_event" ? "replay" : u;
    return this._prepareEvent(t, e, n, r).then((a) => {
      if (a === null)
        throw this.recordDroppedEvent("event_processor", y), I("An event processor returned `null`, will not send event.");
      if (e.data && e.data.__sentry__ === !0)
        return a;
      const f = lt(this, s, a, e);
      return dt(f, h);
    }).then((a) => {
      if (a === null) {
        if (this.recordDroppedEvent("before_send", y), o) {
          const v = 1 + (t.spans || []).length;
          this.recordDroppedEvent("before_send", "span", v);
        }
        throw I(`${h} returned \`null\`, will not send event.`);
      }
      const E = n.getSession() || r.getSession();
      if (d && E && this._updateSessionFromEvent(E, a), o) {
        const _ = a.sdkProcessingMetadata?.spanCountBeforeProcessing || 0, v = a.spans ? a.spans.length : 0, P = _ - v;
        P > 0 && this.recordDroppedEvent("before_send", "span", P);
      }
      const f = a.transaction_info;
      if (o && f && a.transaction !== t.transaction) {
        const _ = "custom";
        a.transaction_info = {
          ...f,
          source: _
        };
      }
      return this.sendEvent(a, e), a;
    }).then(null, (a) => {
      throw M(a) || C(a) ? a : (this.captureException(a, {
        data: {
          __sentry__: !0
        },
        originalException: a
      }), g(
        `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${a}`
      ));
    });
  }
  /**
   * Occupies the client with processing and event
   */
  _process(t) {
    this._numProcessing++, t.then(
      (e) => (this._numProcessing--, e),
      (e) => (this._numProcessing--, e)
    );
  }
  /**
   * Clears outcomes on this client and returns them.
   */
  _clearOutcomes() {
    const t = this._outcomes;
    return this._outcomes = {}, Object.entries(t).map(([e, n]) => {
      const [r, s] = e.split(":");
      return {
        reason: r,
        category: s,
        quantity: n
      };
    });
  }
  /**
   * Sends client reports as an envelope.
   */
  _flushOutcomes() {
    l && p.log("Flushing outcomes...");
    const t = this._clearOutcomes();
    if (t.length === 0) {
      l && p.log("No outcomes to send");
      return;
    }
    if (!this._dsn) {
      l && p.log("No dsn provided, will not send outcomes");
      return;
    }
    l && p.log("Sending outcomes:", t);
    const e = q(t, this._options.tunnel && K(this._dsn));
    this.sendEnvelope(e);
  }
  /**
   * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.
   */
}
function dt(i, t) {
  const e = `${t} must return \`null\` or a valid event.`;
  if (nt(i))
    return i.then(
      (n) => {
        if (!k(n) && n !== null)
          throw g(e);
        return n;
      },
      (n) => {
        throw g(`${t} rejected with ${n}`);
      }
    );
  if (!k(i) && i !== null)
    throw g(e);
  return i;
}
function lt(i, t, e, n) {
  const { beforeSend: r, beforeSendTransaction: s, beforeSendSpan: c } = t;
  let o = e;
  if (b(o) && r)
    return r(o, n);
  if (B(o)) {
    if (c) {
      const d = c(ct(o));
      if (d ? o = st(e, pt(d)) : N(), o.spans) {
        const u = [];
        for (const h of o.spans) {
          const m = c(h);
          m ? u.push(m) : (N(), u.push(h));
        }
        o.spans = u;
      }
    }
    if (s) {
      if (o.spans) {
        const d = o.spans.length;
        o.sdkProcessingMetadata = {
          ...e.sdkProcessingMetadata,
          spanCountBeforeProcessing: d
        };
      }
      return s(o, n);
    }
  }
  return o;
}
function b(i) {
  return i.type === void 0;
}
function B(i) {
  return i.type === "transaction";
}
export {
  Ct as Client
};
