import { addExceptionMechanism as u, addExceptionTypeValue as v } from "./index121.js";
import { resolvedSyncPromise as d } from "./index130.js";
import { isErrorEvent as E, isDOMError as y, isDOMException as O, isError as h, isPlainObject as F, isEvent as p, isParameterizedString as M } from "./index132.js";
import { getClient as $ } from "./index120.js";
import { normalizeToSize as T } from "./index133.js";
import { extractExceptionKeysForMessage as j } from "./index119.js";
function _(r, e) {
  const n = l(r, e), s = {
    type: z(e),
    value: P(e)
  };
  return n.length && (s.stacktrace = { frames: n }), s.type === void 0 && s.value === "" && (s.value = "Unrecoverable error caught"), s;
}
function A(r, e, n, s) {
  const t = $()?.getOptions().normalizeDepth, o = I(e), a = {
    __serialized__: T(e, t)
  };
  if (o)
    return {
      exception: {
        values: [_(r, o)]
      },
      extra: a
    };
  const c = {
    exception: {
      values: [
        {
          type: p(e) ? e.constructor.name : s ? "UnhandledRejection" : "Error",
          value: N(e, { isUnhandledRejection: s })
        }
      ]
    },
    extra: a
  };
  if (n) {
    const g = l(r, n);
    g.length && (c.exception.values[0].stacktrace = { frames: g });
  }
  return c;
}
function f(r, e) {
  return {
    exception: {
      values: [_(r, e)]
    }
  };
}
function l(r, e) {
  const n = e.stacktrace || e.stack || "", s = D(e), i = S(e);
  try {
    return r(n, s, i);
  } catch {
  }
  return [];
}
const k = /Minified React error #\d+;/i;
function D(r) {
  return r && k.test(r.message) ? 1 : 0;
}
function S(r) {
  return typeof r.framesToPop == "number" ? r.framesToPop : 0;
}
function b(r) {
  return typeof WebAssembly < "u" && typeof WebAssembly.Exception < "u" ? r instanceof WebAssembly.Exception : !1;
}
function z(r) {
  const e = r?.name;
  return !e && b(r) ? r.message && Array.isArray(r.message) && r.message.length == 2 ? r.message[0] : "WebAssembly.Exception" : e;
}
function P(r) {
  const e = r?.message;
  return b(r) ? Array.isArray(r.message) && r.message.length == 2 ? r.message[1] : "wasm exception" : e ? e.error && typeof e.error.message == "string" ? e.error.message : e : "No error message";
}
function q(r, e, n, s) {
  const i = n?.syntheticException || void 0, t = w(r, e, i, s);
  return u(t), t.level = "error", n?.event_id && (t.event_id = n.event_id), d(t);
}
function B(r, e, n = "info", s, i) {
  const t = s?.syntheticException || void 0, o = m(r, e, t, i);
  return o.level = n, s?.event_id && (o.event_id = s.event_id), d(o);
}
function w(r, e, n, s, i) {
  let t;
  if (E(e) && e.error)
    return f(r, e.error);
  if (y(e) || O(e)) {
    const o = e;
    if ("stack" in e)
      t = f(r, e);
    else {
      const a = o.name || (y(o) ? "DOMError" : "DOMException"), c = o.message ? `${a}: ${o.message}` : a;
      t = m(r, c, n, s), v(t, c);
    }
    return "code" in o && (t.tags = { ...t.tags, "DOMException.code": `${o.code}` }), t;
  }
  return h(e) ? f(r, e) : F(e) || p(e) ? (t = A(r, e, n, i), u(t, {
    synthetic: !0
  }), t) : (t = m(r, e, n, s), v(t, `${e}`), u(t, {
    synthetic: !0
  }), t);
}
function m(r, e, n, s) {
  const i = {};
  if (s && n) {
    const t = l(r, n);
    t.length && (i.exception = {
      values: [{ value: e, stacktrace: { frames: t } }]
    }), u(i, { synthetic: !0 });
  }
  if (M(e)) {
    const { __sentry_template_string__: t, __sentry_template_values__: o } = e;
    return i.logentry = {
      message: t,
      params: o
    }, i;
  }
  return i.message = e, i;
}
function N(r, { isUnhandledRejection: e }) {
  const n = j(r), s = e ? "promise rejection" : "exception";
  return E(r) ? `Event \`ErrorEvent\` captured as ${s} with message \`${r.message}\`` : p(r) ? `Event \`${W(r)}\` (type=${r.type}) captured as ${s}` : `Object captured as ${s} with keys: ${n}`;
}
function W(r) {
  try {
    const e = Object.getPrototypeOf(r);
    return e ? e.constructor.name : void 0;
  } catch {
  }
}
function I(r) {
  for (const e in r)
    if (Object.prototype.hasOwnProperty.call(r, e)) {
      const n = r[e];
      if (n instanceof Error)
        return n;
    }
}
export {
  q as eventFromException,
  B as eventFromMessage,
  w as eventFromUnknownInput,
  _ as exceptionFromError,
  P as extractMessage,
  z as extractType
};
