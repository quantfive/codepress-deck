import { j as ye } from "./index7.js";
import W, { createContext as we, useState as L, useEffect as Q, useCallback as V, useMemo as se, useContext as Ve } from "react";
import { useForm as Te } from "./index28.js";
import { getCleanElementHTML as K, saveVisualEditorChanges as xe } from "./index15.js";
import { detectRepositoryInfo as Ee } from "./index29.js";
import { logger as A } from "./index12.js";
const Re = [
  "paddingTop",
  "paddingRight",
  "paddingBottom",
  "paddingLeft",
  "marginTop",
  "marginRight",
  "marginBottom",
  "marginLeft"
], Z = [
  "px",
  "em",
  "rem",
  "%",
  "vw",
  "vh",
  "vmin",
  "vmax",
  "cm",
  "mm",
  "in",
  "pt",
  "pc",
  "fr"
], k = [
  "auto",
  "initial",
  "inherit",
  "unset",
  "normal",
  "none",
  "cover",
  "contain",
  "fill",
  "stretch"
];
function Le(C) {
  const d = /^data:image\/([^;+]+)/i.exec(C);
  return d ? d[1].toLowerCase() : "png";
}
const $e = (C) => {
  if (C == null) return "";
  const d = String(C).trim();
  if (d === "") return "";
  if (Z.some(
    (y) => d.endsWith(y) && isNaN(parseFloat(d))
  ) || // e.g. 10px (valid) vs 10pxpx (invalid from parseFloat perspective)
  Z.some(
    (y) => d.endsWith(y) && !isNaN(parseFloat(d.slice(0, -y.length)))
  ) || // handles cases like "10px"
  k.includes(d.toLowerCase()) || d.startsWith("var(") || d.startsWith("calc(") || d.startsWith("clamp(") || d.startsWith("min(") || d.startsWith("max(")) {
    const y = Z.find((T) => d.endsWith(T));
    if (y) {
      const T = d.slice(0, -y.length);
      if (T === "" || isNaN(parseFloat(T)))
        return k.includes(d.toLowerCase()), d;
    } else !k.includes(d.toLowerCase()) && !d.startsWith("var(") && !d.startsWith("calc(") && !d.startsWith("clamp(") && !d.startsWith("min(") && d.startsWith("max(");
    return d;
  }
  return /^-?\d+(\.\d+)?$/.test(d) ? `${d}px` : d;
}, P = {
  elementType: "",
  availableSections: {},
  position: "",
  left: "",
  top: "",
  right: "",
  bottom: "",
  width: "",
  height: "",
  display: "",
  flexDirection: "",
  flexWrap: "",
  justifyContent: "",
  alignItems: "",
  alignContent: "",
  justifyItems: "",
  order: "",
  alignSelf: "",
  gridTemplateColumns: "",
  gridTemplateRows: "",
  gap: "",
  rowGap: "",
  columnGap: "",
  gridColumn: "",
  gridRow: "",
  overflow: "",
  overflowX: "",
  overflowY: "",
  padding: "",
  paddingTop: "",
  paddingRight: "",
  paddingBottom: "",
  paddingLeft: "",
  margin: "",
  marginTop: "",
  marginRight: "",
  marginBottom: "",
  marginLeft: "",
  showAdvancedSpacing: !1,
  rotation: 0,
  opacity: 100,
  cornerRadius: "",
  fontSize: "",
  lineHeight: "",
  letterSpacing: "",
  fontFamily: "Open Sans",
  textAlign: "left",
  fontWeight: "",
  fontStyle: "",
  textDecoration: "",
  text: "",
  href: "",
  backgroundColor: "",
  backgroundImage: "",
  backgroundSize: "cover",
  backgroundPosition: "center",
  backgroundRepeat: "no-repeat",
  imageSrc: "",
  imageAlt: "",
  color: "",
  colorOpacity: 100,
  hover_backgroundColor: "",
  hover_color: "",
  hover_colorOpacity: 100,
  hover_fontSize: "",
  hover_opacity: 100,
  hover_cornerRadius: "",
  hover_padding: "",
  hover_paddingTop: "",
  hover_paddingRight: "",
  hover_paddingBottom: "",
  hover_paddingLeft: "",
  hover_margin: "",
  hover_marginTop: "",
  hover_marginRight: "",
  hover_marginBottom: "",
  hover_marginLeft: "",
  hover_width: "",
  hover_height: "",
  hover_lineHeight: "",
  hover_letterSpacing: "",
  hover_textAlign: "left",
  active_backgroundColor: "",
  active_color: "",
  active_colorOpacity: 100,
  active_fontSize: "",
  active_opacity: 100,
  active_cornerRadius: "",
  active_padding: "",
  active_paddingTop: "",
  active_paddingRight: "",
  active_paddingBottom: "",
  active_paddingLeft: "",
  active_margin: "",
  active_marginTop: "",
  active_marginRight: "",
  active_marginBottom: "",
  active_marginLeft: "",
  active_width: "",
  active_height: "",
  active_lineHeight: "",
  active_letterSpacing: "",
  active_textAlign: "left"
}, ie = we(
  void 0
), Oe = ({
  children: C,
  demo: d = !1
}) => {
  const { control: y, watch: T, reset: p, setValue: O, getValues: v } = Te({
    defaultValues: P
  }), S = W.useRef(!1), [f, w] = L({}), [h, F] = L(
    null
  ), [ae, D] = L(!1), U = W.useRef(
    null
  ), [x, ce] = L("normal"), [j, z] = L([]), [ee, M] = L([]), $ = W.useRef(!1), q = W.useRef(!1), E = W.useRef(null);
  Q(() => {
    if (!h) return;
    const e = f[h];
    if (!e) return;
    const n = e.currentValues, t = /* @__PURE__ */ new Set();
    for (const r of Object.keys(n))
      if (r.startsWith("hover_"))
        t.add(r.replace("hover_", ""));
      else if (r.startsWith("active_"))
        t.add(r.replace("active_", ""));
      else {
        if ([
          "elementType",
          "availableSections",
          "showAdvancedSpacing",
          "text",
          "href"
        ].includes(r))
          continue;
        t.add(r);
      }
    const s = {};
    t.forEach((r) => {
      const o = `hover_${r}`, a = `active_${r}`;
      if (x === "hover") {
        const u = n[o], c = n[r];
        u !== void 0 && u !== "" || (s[r] = c);
      } else if (x === "active") {
        const u = n[a], c = n[r];
        u !== void 0 && u !== "" || (s[r] = c);
      } else {
        const u = n[r];
        s[r] = u;
      }
    }), S.current = !0, Object.entries(s).forEach(([r, o]) => {
      O(r, o, { shouldDirty: !1 });
    }), setTimeout(() => {
      S.current = !1;
    }, 0);
  }, [x, h, f]);
  const H = V(
    (e, n) => {
      w((t) => t[e] ? {
        ...t,
        [e]: {
          ...t[e],
          currentValues: { ...t[e].currentValues, ...n }
        }
      } : t);
    },
    []
    //[trackedElements]
  ), te = V(
    (e) => {
      z((n) => [
        ...n,
        { id: `${Date.now()}-${Math.random().toString(36).slice(2, 7)}`, timestamp: Date.now(), ...e }
      ]);
    },
    []
  ), le = (e) => {
    q.current = !0, E.current = { fpId: e, patch: {}, inversePatch: {} };
  }, de = (e, n, t) => {
    E.current && (e in E.current.inversePatch || (E.current.inversePatch[e] = n ?? ""), E.current.patch[e] = t ?? "");
  }, ue = () => {
    const e = E.current;
    q.current = !1, e && Object.keys(e.patch).length && (te({
      fpId: e.fpId,
      patch: e.patch,
      inversePatch: e.inversePatch,
      label: e.label,
      source: "batch"
    }), M([])), E.current = null;
  }, G = (e, n, t) => {
    if (n === "text") {
      if (e instanceof HTMLInputElement || e instanceof HTMLTextAreaElement)
        return e.value = String(t ?? ""), !0;
      if (e.isContentEditable) {
        const r = String(t ?? "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        return e.innerHTML = r.replace(/\n/g, "<br>"), !0;
      }
      return e.textContent = String(t ?? ""), !0;
    }
    return !1;
  }, I = V(
    (e, n) => {
      if (w((t) => {
        const s = t[e]?.element;
        if (!s) return t;
        const r = { ...t[e].currentValues, ...n }, o = { ...t, [e]: { ...t[e], currentValues: r } };
        return Object.entries(n).forEach(([a, u]) => {
          if (G(s, a, u)) return;
          const g = a.match(/^(hover|active)_/), i = g ? g[1] : null, l = i ? a.replace(`${i}_`, "") : a, m = new CustomEvent("design-panel-style-update", {
            detail: {
              fpId: e,
              [l]: u,
              _isHoverState: i === "hover",
              _pseudoState: i,
              _baseProperty: l
            },
            bubbles: !0,
            composed: !0
          });
          document.dispatchEvent(m);
        }), o;
      }), e === h) {
        const t = { ...v(), ...n };
        S.current = !0, p(t), setTimeout(() => S.current = !1, 0);
      }
    },
    [h, p, v]
  ), Y = V(
    (e, n) => {
      let t = e.getAttribute("codepress-data-fp");
      if ((d || !t) && (t || console.warn(
        "Selected element does not have a codepress-data-fp attribute. Changes may not be tracked correctly."
      ), t = `temp_${(/* @__PURE__ */ new Date()).getTime()}`, e.setAttribute("codepress-data-fp", t)), h && f[h]) {
        const s = v();
        H(h, s);
      }
      F(t), f[t] ? (w((s) => ({
        ...s,
        [t]: {
          ...s[t],
          element: e
        }
      })), S.current = !0, p(f[t].currentValues), setTimeout(() => {
        S.current = !1;
      }, 0)) : (w((s) => ({
        ...s,
        [t]: {
          fpId: t,
          element: e,
          originalHtml: K(e, !1),
          originalValues: n,
          currentValues: n,
          moveChanges: []
        }
      })), S.current = !0, p(n), setTimeout(() => {
        S.current = !1;
      }, 0));
    },
    [
      h,
      v,
      p,
      f,
      H,
      d
    ]
  );
  Q(() => {
    const e = (s) => {
      const { element: r, initialValues: o } = s.detail;
      r && Y(r, o);
    }, n = () => {
      F(null), p(P);
    }, t = (s) => {
      const { moveChange: r, sourceElement: o } = s.detail, a = o.getAttribute("codepress-data-fp");
      if (a && f[a])
        w((u) => ({
          ...u,
          [a]: {
            ...u[a],
            moveChanges: [...u[a].moveChanges || [], r]
          }
        })), A.info("✅ Move change tracked:", { sourceFpId: a, moveChange: r });
      else {
        const u = { ...P }, c = {
          fpId: a || `temp_${Date.now()}`,
          element: o,
          originalHtml: K(o, !1),
          originalValues: u,
          currentValues: u,
          moveChanges: [r]
        };
        w((g) => ({
          ...g,
          [c.fpId]: c
        })), A.info("✅ New element tracked with move change:", {
          fpId: c.fpId,
          moveChange: r
        });
      }
    };
    return document.addEventListener(
      "codepress-select-element",
      e
    ), document.addEventListener(
      "codepress-deselect-element",
      n
    ), document.addEventListener(
      "codepress-element-moved",
      t
    ), () => {
      document.removeEventListener(
        "codepress-select-element",
        e
      ), document.removeEventListener(
        "codepress-deselect-element",
        n
      ), document.removeEventListener(
        "codepress-element-moved",
        t
      );
    };
  }, [Y, p, f]), Q(() => (U.current?.unsubscribe(), U.current = T((e, { name: n, type: t }) => {
    if (S.current || !n || !h)
      return;
    const s = String(n), r = f[h]?.currentValues;
    let o = r ? r[s] : void 0, a = e[s];
    (Re.some((X) => X === s) || (s === "padding" || s === "margin")) && (a = $e(a));
    const g = s.match(/^(hover|active)_/), i = g ? g[1] : null, l = i ? s.replace(`${i}_`, "") : s, m = h ? f[h]?.element : null, _ = !!m?.isContentEditable ? m.innerHTML : void 0;
    !$.current && !q.current && (te({
      fpId: h,
      patch: { [s]: a },
      inversePatch: { [s]: o },
      source: "field",
      ..._ ? { domHtmlBefore: _ } : {}
    }), M([])), H(
      h,
      e
    );
    const R = {
      fpId: h,
      // Let consumers know which element this update belongs to
      [l]: a,
      _isHoverState: i === "hover",
      // legacy flag
      _pseudoState: i,
      // new flexible flag ("hover" | "active" | null)
      _baseProperty: l
    }, B = new CustomEvent("design-panel-style-update", {
      detail: R,
      bubbles: !0,
      composed: !0
    });
    document.dispatchEvent(B);
  }), () => U.current?.unsubscribe()), [T, h, v]);
  const ge = V(
    (e) => {
      if (!h) return;
      const n = v();
      le(h);
      const t = { ...e }, s = (i) => {
        const l = i.trim().split(/\s+/);
        switch (l.length) {
          case 1:
            return [l[0], l[0], l[0], l[0]];
          case 2:
            return [l[0], l[1], l[0], l[1]];
          // top/right/bottom/left
          case 3:
            return [l[0], l[1], l[2], l[1]];
          case 4:
            return [l[0], l[1], l[2], l[3]];
          default:
            return [i, i, i, i];
        }
      }, r = (i, l) => {
        if (i === "padding" || i === "margin") {
          if (typeof l == "string") {
            const [m, b, _, R] = s(l);
            t[`${i}Top`] = m, t[`${i}Right`] = b, t[`${i}Bottom`] = _, t[`${i}Left`] = R;
          }
        } else i === "border" && (t[`${i}Top`] = l, t[`${i}Right`] = l, t[`${i}Bottom`] = l, t[`${i}Left`] = l);
      };
      Object.entries(e).forEach(([i, l]) => {
        (i === "padding" || i === "margin" || i === "border") && r(i, l);
      });
      const o = (i) => {
        const m = ["Top", "Right", "Bottom", "Left"].map((J) => {
          const oe = `${i}${J}`;
          return t[oe] ?? v()[oe];
        }), [b, _, R, B] = m, X = m.every((J) => J === b);
        let N = "";
        X ? N = b ?? "" : b === R && _ === B ? N = `${b} ${_}` : _ === B ? N = `${b} ${_} ${R}` : N = `${b} ${_} ${R} ${B}`, t[i] = N;
      }, a = Object.keys(e), u = a.some(
        (i) => ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft"].includes(
          i
        )
      ), c = a.some(
        (i) => ["marginTop", "marginRight", "marginBottom", "marginLeft"].includes(i)
      ), g = a.some(
        (i) => ["borderTop", "borderRight", "borderBottom", "borderLeft"].includes(i)
      );
      u && o("padding"), c && o("margin"), g && o("border"), Object.entries(t).forEach(([i, l]) => {
        const m = x === "normal" ? i : `${x}_${i}`, b = n[m];
        de(m, b, l), O(m, l, {
          shouldDirty: !0
        });
      }), ue(), H(h, v());
    },
    [h, O, v, H, x]
  ), ne = (e, n) => {
    const t = [];
    return (/* @__PURE__ */ new Set([
      ...Object.keys(e),
      ...Object.keys(n)
    ])).forEach((r) => {
      if ([
        "elementType",
        "availableSections",
        "showAdvancedSpacing",
        "text",
        "href"
      ].includes(r))
        return;
      const o = e[r], a = n[r];
      let u = !1;
      if (r === "fontWeight") {
        const c = String(o) === "bold" || Number(o) >= 600, g = String(a) === "bold" || Number(a) >= 600;
        u = c !== g;
      } else if (r === "textDecoration") {
        const c = String(o).includes("underline"), g = String(a).includes("underline");
        u = c !== g;
      } else if (o !== a) {
        const c = (g) => g == null ? "" : String(g);
        u = c(o) !== c(a);
      }
      if (u) {
        const c = r.startsWith("hover_"), g = c ? r.replace("hover_", "") : r;
        t.push({
          property: g,
          oldValue: String(e[r] ?? ""),
          newValue: String(n[r] ?? ""),
          isHoverState: c
        });
      }
    }), t;
  }, re = (e, n) => {
    const t = [];
    return e.text !== n.text && t.push({
      oldText: String(e.text ?? ""),
      newText: String(n.text ?? "")
    }), e.href !== n.href && t.push({
      oldText: String(e.href ?? ""),
      newText: String(n.href ?? "")
    }), t;
  };
  function he(e) {
    let n = e?.parentElement || null;
    for (; n; ) {
      const t = n.getAttribute("codepress-data-fp");
      if (t && !t.startsWith("new_span_"))
        return t;
      n = n.parentElement;
    }
    return null;
  }
  const me = V(
    async (e, n) => {
      if (d)
        return A.debug("DEMO MODE: Changes would be saved here.", {
          changes: Object.values(f)
        }), w({}), F(null), p(P), !0;
      D(!0);
      const t = Ee();
      if (!t?.repository)
        return A.error(
          "Could not determine repository information. Cannot save changes."
        ), D(!1), alert(
          "Could not determine repository information. Cannot save changes."
        ), !1;
      const s = Object.values(f).filter((o) => {
        const a = ne(
          o.originalValues,
          o.currentValues
        ), u = re(
          o.originalValues,
          o.currentValues
        ), c = o.moveChanges || [];
        return a.length > 0 || u.length > 0 || c.length > 0;
      }).map((o) => {
        let a = ne(
          o.originalValues,
          o.currentValues
        );
        const u = re(
          o.originalValues,
          o.currentValues
        ), c = a.some(
          (m) => m.property === "imageSrc" && m.newValue.startsWith("data:image")
        ), g = c && o.currentValues.imageSrc ? Le(o.currentValues.imageSrc) : "png", i = c ? `images/image-${Date.now()}.${g}` : void 0;
        let l = K(o.element, !1);
        return c && i && (l = l.replace(
          /src="data:image\/[^"]+"/,
          `src="/${i}"`
        )), c && i && (a = a.map((m) => m.property === "imageSrc" && m.newValue.startsWith("data:image") ? {
          ...m,
          newValue: `/${i}`
        } : m)), {
          // If the tracked element is a *new* <span> that we injected for
          // inline formatting we actually want to reference its *parent*
          // element so that the engine updates the correct file instead of
          // trying to locate a temporary fpId that does not exist in the
          // source. We detect our synthetic spans by checking that the tag
          // is SPAN *and* that a parent element with a codepress-data-fp
          // attribute exists.
          encodedLocation: o.element.tagName === "SPAN" && he(o.element) || o.fpId,
          oldHtml: o.originalHtml,
          newHtml: l,
          styleChanges: a.map((m) => o.element.tagName === "SPAN" ? {
            ...m,
            target: o.element.textContent || null,
            htmlTag: o.element.tagName.toLowerCase()
          } : m),
          textChanges: u,
          moveChanges: o.moveChanges || [],
          imageData: c ? o.currentValues.imageSrc : void 0,
          filename: i,
          browserWidth: window.innerWidth,
          browserHeight: window.innerHeight
        };
      });
      if (s.length === 0)
        return D(!1), !0;
      const r = await xe({
        changes: s,
        githubRepoName: t.repository,
        githubBaseBranchName: t?.branch,
        githubBranchName: e || t?.branch,
        commitMessage: n
      });
      return r ? w((o) => {
        const a = { ...o };
        return s.forEach((u) => {
          const c = a[u.encodedLocation];
          c && (a[u.encodedLocation] = {
            ...c,
            originalValues: c.currentValues,
            originalHtml: K(c.element, !1),
            moveChanges: []
            // Clear move changes after successful save
          });
        }), a;
      }) : A.error("Some changes failed to save."), D(!1), r;
    },
    [f, d, p]
  ), fe = V(() => {
    w((e) => {
      const n = { ...e };
      return Object.keys(n).forEach((t) => {
        const s = n[t];
        if (t.startsWith("new_span_")) {
          const c = s.element;
          if (c && c.parentNode) {
            for (; c.firstChild; )
              c.parentNode.insertBefore(c.firstChild, c);
            c.parentNode.removeChild(c);
          } else {
            const g = document.querySelector(
              `[codepress-data-fp="${t}"]`
            );
            if (g && g.parentNode) {
              for (; g.firstChild; )
                g.parentNode.insertBefore(g.firstChild, g);
              g.parentNode.removeChild(g);
            }
          }
          delete n[t];
          return;
        }
        n[t] = {
          ...s,
          currentValues: s.originalValues,
          moveChanges: []
          // Clear any move changes when canceling
        };
        const o = s.element, a = s.originalValues;
        G(o, "text", a.text), G(o, "href", a.href);
        const u = new CustomEvent("design-panel-style-update", {
          detail: {
            ...s.originalValues,
            _isRevert: !0,
            fpId: t
          },
          bubbles: !0,
          composed: !0
        });
        document.dispatchEvent(u);
      }), n;
    }), h && f[h] ? p(f[h].originalValues) : p(P);
  }, [h, f, p]), pe = V(() => {
    z((e) => {
      const n = e[e.length - 1];
      if (!n) return e;
      const s = f[n.fpId]?.element, r = s?.isContentEditable ? s.innerHTML : void 0;
      $.current = !0;
      try {
        if (s && s.isContentEditable && n.domHtmlBefore !== void 0) {
          s.innerHTML = n.domHtmlBefore;
          const o = { ...v() };
          o.text = s.innerText, S.current = !0, p(o), setTimeout(() => S.current = !1, 0);
        } else
          I(n.fpId, n.inversePatch);
        M((o) => [
          ...o,
          { ...n, ...r ? { domHtmlAfter: r } : {} }
        ]);
      } finally {
        $.current = !1;
      }
      return e.slice(0, -1);
    });
  }, [I, v, p, f]), ve = V(() => {
    M((e) => {
      const n = e[e.length - 1];
      if (!n) return e;
      const s = f[n.fpId]?.element;
      $.current = !0;
      try {
        if (s && s.isContentEditable && n.domHtmlAfter !== void 0) {
          s.innerHTML = n.domHtmlAfter;
          const r = { ...v() };
          r.text = s.innerText, S.current = !0, p(r), setTimeout(() => S.current = !1, 0);
        } else
          I(n.fpId, n.patch);
        z((r) => [...r, n]);
      } finally {
        $.current = !1;
      }
      return e.slice(0, -1);
    });
  }, [I, v, p, f]), Se = se(() => j.length > 0, [j]), be = se(() => ee.length > 0, [ee]), Ce = j.length, _e = {
    control: y,
    watch: T,
    reset: p,
    setValue: O,
    getValues: v,
    trackedElements: f,
    activeElementFpId: h,
    selectElement: Y,
    updateActiveElementStyle: ge,
    saveAllChanges: me,
    cancelAllChanges: fe,
    totalUnsavedChanges: Ce,
    isSaving: ae,
    isDemo: d,
    editingState: x,
    setEditingState: ce,
    history: j,
    canUndo: Se,
    undo: pe,
    canRedo: be,
    redo: ve
  };
  return /* @__PURE__ */ ye.jsx(ie.Provider, { value: _e, children: C });
}, De = () => {
  const C = Ve(ie);
  if (C === void 0)
    throw new Error(
      "useVisualEditor must be used within a VisualEditorProvider"
    );
  return C;
};
export {
  Oe as VisualEditorProvider,
  P as defaultValues,
  De as useVisualEditor
};
