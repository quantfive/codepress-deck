import { DEBUG_BUILD as h } from "./index143.js";
import { WINDOW as v } from "./index116.js";
import { defineIntegration as B } from "./index144.js";
import { addConsoleInstrumentationHandler as H } from "./index145.js";
import { addClickKeypressInstrumentationHandler as S } from "./index146.js";
import { addXhrInstrumentationHandler as x, SENTRY_XHR_DATA_KEY as I } from "./index147.js";
import { addFetchInstrumentationHandler as T } from "./index148.js";
import { addHistoryInstrumentationHandler as L } from "./index149.js";
import { getClient as f } from "./index120.js";
import { addBreadcrumb as u } from "./index150.js";
import { getEventDescription as A } from "./index121.js";
import { debug as E } from "./index151.js";
import { htmlTreeAsString as N, getComponentName as O } from "./index118.js";
import { safeJoin as y } from "./index152.js";
import { severityLevelFromString as R } from "./index153.js";
import { getBreadcrumbLogLevelFromHttpStatusCode as _ } from "./index154.js";
import { parseUrl as p } from "./index155.js";
const d = 1024, C = "Breadcrumbs", $ = (r = {}) => {
  const o = {
    console: !0,
    dom: !0,
    fetch: !0,
    history: !0,
    sentry: !0,
    xhr: !0,
    ...r
  };
  return {
    name: C,
    setup(t) {
      o.console && H(k(t)), o.dom && S(X(t, o.dom)), o.xhr && x(q(t)), o.fetch && T(w(t)), o.history && L(G(t)), o.sentry && t.on("beforeSendEvent", F(t));
    }
  };
}, st = B($);
function F(r) {
  return function(t) {
    f() === r && u(
      {
        category: `sentry.${t.type === "transaction" ? "transaction" : "event"}`,
        event_id: t.event_id,
        level: t.level,
        message: A(t)
      },
      {
        event: t
      }
    );
  };
}
function X(r, o) {
  return function(e) {
    if (f() !== r)
      return;
    let m, n, s = typeof o == "object" ? o.serializeAttribute : void 0, i = typeof o == "object" && typeof o.maxStringLength == "number" ? o.maxStringLength : void 0;
    i && i > d && (h && E.warn(
      `\`dom.maxStringLength\` cannot exceed ${d}, but a value of ${i} was configured. Sentry will use ${d} instead.`
    ), i = d), typeof s == "string" && (s = [s]);
    try {
      const a = e.event, g = z(a) ? a.target : a;
      m = N(g, { keyAttrs: s, maxStringLength: i }), n = O(g);
    } catch {
      m = "<unknown>";
    }
    if (m.length === 0)
      return;
    const c = {
      category: `ui.${e.name}`,
      message: m
    };
    n && (c.data = { "ui.component_name": n }), u(c, {
      event: e.event,
      name: e.name,
      global: e.global
    });
  };
}
function k(r) {
  return function(t) {
    if (f() !== r)
      return;
    const e = {
      category: "console",
      data: {
        arguments: t.args,
        logger: "console"
      },
      level: R(t.level),
      message: y(t.args, " ")
    };
    if (t.level === "assert")
      if (t.args[0] === !1)
        e.message = `Assertion failed: ${y(t.args.slice(1), " ") || "console.assert"}`, e.data.arguments = t.args.slice(1);
      else
        return;
    u(e, {
      input: t.args,
      level: t.level
    });
  };
}
function q(r) {
  return function(t) {
    if (f() !== r)
      return;
    const { startTimestamp: e, endTimestamp: m } = t, n = t.xhr[I];
    if (!e || !m || !n)
      return;
    const { method: s, url: i, status_code: c, body: a } = n, g = {
      method: s,
      url: i,
      status_code: c
    }, b = {
      xhr: t.xhr,
      input: a,
      startTimestamp: e,
      endTimestamp: m
    }, l = {
      category: "xhr",
      data: g,
      type: "http",
      level: _(c)
    };
    r.emit("beforeOutgoingRequestBreadcrumb", l, b), u(l, b);
  };
}
function w(r) {
  return function(t) {
    if (f() !== r)
      return;
    const { startTimestamp: e, endTimestamp: m } = t;
    if (m && !(t.fetchData.url.match(/sentry_key/) && t.fetchData.method === "POST"))
      if (t.fetchData.method, t.fetchData.url, t.error) {
        const n = t.fetchData, s = {
          data: t.error,
          input: t.args,
          startTimestamp: e,
          endTimestamp: m
        }, i = {
          category: "fetch",
          data: n,
          level: "error",
          type: "http"
        };
        r.emit("beforeOutgoingRequestBreadcrumb", i, s), u(i, s);
      } else {
        const n = t.response, s = {
          ...t.fetchData,
          status_code: n?.status
        };
        t.fetchData.request_body_size, t.fetchData.response_body_size, n?.status;
        const i = {
          input: t.args,
          response: n,
          startTimestamp: e,
          endTimestamp: m
        }, c = {
          category: "fetch",
          data: s,
          type: "http",
          level: _(s.status_code)
        };
        r.emit("beforeOutgoingRequestBreadcrumb", c, i), u(c, i);
      }
  };
}
function G(r) {
  return function(t) {
    if (f() !== r)
      return;
    let e = t.from, m = t.to;
    const n = p(v.location.href);
    let s = e ? p(e) : void 0;
    const i = p(m);
    s?.path || (s = n), n.protocol === i.protocol && n.host === i.host && (m = i.relative), n.protocol === s.protocol && n.host === s.host && (e = s.relative), u({
      category: "navigation",
      data: {
        from: e,
        to: m
      }
    });
  };
}
function z(r) {
  return !!r && !!r.target;
}
export {
  st as breadcrumbsIntegration
};
