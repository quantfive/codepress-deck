import { isInstanceOf as f } from "./index132.js";
function x(n, e, c, a, i, s) {
  if (!i.exception?.values || !s || !f(s.originalException, Error))
    return;
  const r = i.exception.values.length > 0 ? i.exception.values[i.exception.values.length - 1] : void 0;
  r && (i.exception.values = h(
    n,
    e,
    a,
    s.originalException,
    c,
    i.exception.values,
    r,
    0
  ));
}
function h(n, e, c, a, i, s, r, g) {
  if (s.length >= c + 1)
    return s;
  let t = [...s];
  if (f(a[i], Error)) {
    E(r, g);
    const o = n(e, a[i]), u = t.length;
    d(o, i, u, g), t = h(
      n,
      e,
      c,
      a[i],
      i,
      [o, ...t],
      o,
      u
    );
  }
  return Array.isArray(a.errors) && a.errors.forEach((o, u) => {
    if (f(o, Error)) {
      E(r, g);
      const l = n(e, o), p = t.length;
      d(l, `errors[${u}]`, p, g), t = h(
        n,
        e,
        c,
        o,
        i,
        [l, ...t],
        l,
        p
      );
    }
  }), t;
}
function E(n, e) {
  n.mechanism = n.mechanism || { type: "generic", handled: !0 }, n.mechanism = {
    ...n.mechanism,
    ...n.type === "AggregateError" && { is_exception_group: !0 },
    exception_id: e
  };
}
function d(n, e, c, a) {
  n.mechanism = n.mechanism || { type: "generic", handled: !0 }, n.mechanism = {
    ...n.mechanism,
    type: "chained",
    source: e,
    exception_id: c,
    parent_id: a
  };
}
export {
  x as applyAggregateErrorsToEvent
};
