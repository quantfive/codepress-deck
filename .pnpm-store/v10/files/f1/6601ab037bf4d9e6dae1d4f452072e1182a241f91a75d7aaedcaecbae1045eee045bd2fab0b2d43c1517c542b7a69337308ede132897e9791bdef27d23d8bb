const y = 6e4;
function R(e, r = Date.now()) {
  const a = parseInt(`${e}`, 10);
  if (!isNaN(a))
    return a * 1e3;
  const t = Date.parse(`${e}`);
  return isNaN(t) ? 6e4 : t - r;
}
function m(e, r) {
  return e[r] || e.all || 0;
}
function D(e, r, a = Date.now()) {
  return m(e, r) > a;
}
function A(e, { statusCode: r, headers: a }, t = Date.now()) {
  const i = {
    ...e
  }, l = a?.["x-sentry-rate-limits"], c = a?.["retry-after"];
  if (l)
    for (const d of l.trim().split(",")) {
      const [p, o, , , f] = d.split(":", 5), u = parseInt(p, 10), s = (isNaN(u) ? 60 : u) * 1e3;
      if (!o)
        i.all = t + s;
      else
        for (const n of o.split(";"))
          n === "metric_bucket" ? (!f || f.split(";").includes("custom")) && (i[n] = t + s) : i[n] = t + s;
    }
  else c ? i.all = t + R(c, t) : r === 429 && (i.all = t + 60 * 1e3);
  return i;
}
export {
  y as DEFAULT_RETRY_AFTER,
  m as disabledUntil,
  D as isRateLimited,
  R as parseRetryAfterHeader,
  A as updateRateLimits
};
