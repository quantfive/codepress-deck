import { DEBUG_BUILD as s } from "./index208.js";
import { debug as a } from "./index151.js";
import { forEachEnvelopeItem as c, createEnvelope as h, serializeEnvelope as L, envelopeItemTypeToDataCategory as l } from "./index198.js";
import { makePromiseBuffer as T, SENTRY_BUFFER_FULL_ERROR as S } from "./index217.js";
import { updateRateLimits as g, isRateLimited as w } from "./index218.js";
import { resolvedSyncPromise as p } from "./index130.js";
const y = 64;
function B(o, E, d = T(
  o.bufferSize || y
)) {
  let n = {};
  const v = (t) => d.drain(t);
  function R(t) {
    const i = [];
    if (c(t, (e, m) => {
      const r = l(m);
      w(n, r) ? o.recordDroppedEvent("ratelimit_backoff", r) : i.push(e);
    }), i.length === 0)
      return p({});
    const u = h(t[0], i), f = (e) => {
      c(u, (m, r) => {
        o.recordDroppedEvent(e, l(r));
      });
    }, _ = () => E({ body: L(u) }).then(
      (e) => (e.statusCode !== void 0 && (e.statusCode < 200 || e.statusCode >= 300) && s && a.warn(`Sentry responded with status code ${e.statusCode} to sent event.`), n = g(n, e), e),
      (e) => {
        throw f("network_error"), s && a.error("Encountered error running transport request:", e), e;
      }
    );
    return d.add(_).then(
      (e) => e,
      (e) => {
        if (e === S)
          return s && a.error("Skipped sending event because buffer is full."), f("queue_overflow"), p({});
        throw e;
      }
    );
  }
  return {
    send: R,
    flush: v
  };
}
export {
  y as DEFAULT_TRANSPORT_BUFFER_SIZE,
  B as createTransport
};
