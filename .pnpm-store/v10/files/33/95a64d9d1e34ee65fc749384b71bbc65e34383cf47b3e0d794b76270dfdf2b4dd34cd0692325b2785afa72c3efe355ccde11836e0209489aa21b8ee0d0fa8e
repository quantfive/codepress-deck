import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import React, { useEffect, useState } from "react";
import { useVisualEditor } from "../../context/VisualEditorContext.js";
import { Tabs, TabsContent } from "../ui/tabs.js";
import AgentChatOverlay from "./AgentChatOverlay.js";
import ContainerGroup from "./groups/container/ContainerGroup.js";
import ImageGroup from "./groups/ImageGroup.js";
import LayoutGroup from "./groups/LayoutGroup.js";
import StatesMotionGroup from "./groups/StatesMotionGroup.js";
import TextGroup from "./groups/TextGroup.js";
import Header from "./Header.js";
// Add CSS keyframes for the fadeIn animation if not already global
const fadeInKeyframes = `
@keyframes fadeInPopover {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}`;
if (typeof document !== "undefined") {
    const styleId = "codepress-designbar-fadein";
    if (!document.getElementById(styleId)) {
        const style = document.createElement("style");
        style.id = styleId;
        style.textContent = fadeInKeyframes;
        document.head.appendChild(style);
    }
}
// Removed obsolete text-formatting helpers (now handled inside TextGroup)
const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
const DesignBar = ({ onClose, popoverContainer, onOpenDesignPanel, }) => {
    const { activeElementFpId, trackedElements, updateActiveElementStyle } = useVisualEditor();
    const activeElement = activeElementFpId
        ? trackedElements[activeElementFpId]?.element
        : null;
    const initialValues = activeElementFpId
        ? trackedElements[activeElementFpId]?.currentValues
        : null;
    // Track which category tab is active. We initialise it based on the currently
    // selected element so that – on the very first render – the correct panel is
    // already open without waiting for the
    // `useEffect` below to run (which would otherwise cause a noticeable flicker).
    const initialTab = (() => {
        if (activeElement) {
            const tag = activeElement.tagName?.toLowerCase();
            if (tag === "img")
                return "image";
        }
        return "text";
    })();
    const [currentTab, setCurrentTab] = useState(initialTab);
    const [position, setPosition] = useState({ x: 0, y: 0 });
    const [isCustomPosition, setIsCustomPosition] = useState(false);
    const barRef = React.useRef(null);
    // --- Drag support state --- //
    const [isDragging, setIsDragging] = useState(false);
    const dragOffsetRef = React.useRef({ x: 0, y: 0 });
    const [isAgentOpen, setIsAgentOpen] = useState(false);
    const toggleAgent = (open) => setIsAgentOpen(open);
    // ------------------------
    // Drag to reposition logic
    // ------------------------
    const handleHeaderMouseDown = (e) => {
        // Only respond to primary mouse button
        if (e.button !== 0)
            return;
        // Ignore interactive controls inside the header (buttons, inputs, selects, etc.)
        const interactiveAncestor = e.target.closest("button, input, select, textarea, label, [role='button']");
        if (interactiveAncestor) {
            return;
        }
        // Before switching to custom mode, synchronise the stored position to the
        // element’s current viewport location so we start the drag from the right
        // coordinates.
        if (barRef.current) {
            const rect = barRef.current.getBoundingClientRect();
            setPosition({ x: rect.left, y: rect.top });
            dragOffsetRef.current = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top,
            };
        }
        else {
            dragOffsetRef.current = { x: 0, y: 0 };
        }
        setIsCustomPosition(true);
        setIsDragging(true);
        // Prevent text selection during drag
        e.preventDefault();
    };
    // Handle the actual drag movement on the window so that pointer can leave the header
    useEffect(() => {
        if (!isDragging)
            return;
        const handleMouseMove = (ev) => {
            const barWidth = barRef.current?.offsetWidth || 520;
            const barHeight = barRef.current?.offsetHeight || 60;
            let newX = ev.clientX - dragOffsetRef.current.x;
            let newY = ev.clientY - dragOffsetRef.current.y;
            // Constrain within the visible viewport
            newX = clamp(newX, 0, window.innerWidth - barWidth);
            newY = clamp(newY, 0, window.innerHeight - barHeight);
            setPosition({ x: newX, y: newY });
        };
        const handleMouseUp = () => {
            setIsDragging(false);
        };
        window.addEventListener("mousemove", handleMouseMove);
        window.addEventListener("mouseup", handleMouseUp, { once: true });
        return () => {
            window.removeEventListener("mousemove", handleMouseMove);
            window.removeEventListener("mouseup", handleMouseUp);
        };
    }, [isDragging]);
    useEffect(() => {
        if (activeElement) {
            // Switch to Image tab automatically when selecting an <img> element
            const isImg = activeElement?.nodeType === 1 &&
                activeElement.tagName?.toLowerCase() === "img";
            setCurrentTab(isImg ? "image" : "text");
            if (isCustomPosition)
                return; // Keep manual position
            const rect = activeElement.getBoundingClientRect();
            // Use actual bar height if available, otherwise estimate more accurately
            // Padding is 12px top/bottom = 24px, content is roughly 32px = ~56px total
            const estimatedBarHeight = 60; // Slightly higher estimate
            const actualBarHeight = barRef.current?.offsetHeight || estimatedBarHeight;
            const barHeight = actualBarHeight;
            const barWidth = barRef.current?.offsetWidth || 520; // More accurate estimate based on minWidth + padding
            const margin = 16; // Increased margin for better collision avoidance
            const gap = 16; // Increased gap for better visibility
            // Account for scroll position
            const scrollX = window.scrollX;
            const scrollY = window.scrollY;
            // Determine vertical position (above or below)
            const spaceAbove = rect.top;
            const spaceBelow = window.innerHeight - rect.bottom;
            const requiredHeight = barHeight + gap + margin;
            let y;
            if (spaceAbove >= requiredHeight) {
                // Position above the element with gap
                y = rect.top - barHeight - gap + scrollY;
            }
            else if (spaceBelow >= requiredHeight) {
                // Position below the element with gap
                y = rect.bottom + gap + scrollY;
            }
            else {
                // Not enough space either way, prefer above with gap and clamp
                y = clamp(rect.top - barHeight - gap + scrollY, margin + scrollY, window.innerHeight - barHeight - margin + scrollY);
            }
            // Horizontal position - left-align to element and clamp to viewport
            let x = rect.left + scrollX;
            // Simple clamping to ensure within bounds with 16px margin
            x = clamp(x, margin + scrollX, window.innerWidth - barWidth - margin + scrollX);
            y = clamp(y, margin + scrollY, window.innerHeight - barHeight - margin + scrollY);
            setPosition({ x, y });
        }
    }, [activeElement, isCustomPosition]);
    // Recalculate position once the bar is rendered and we have actual dimensions
    useEffect(() => {
        if (isCustomPosition)
            return;
        if (activeElement && barRef.current) {
            const rect = activeElement.getBoundingClientRect();
            const actualBarHeight = barRef.current.offsetHeight;
            const actualBarWidth = barRef.current.offsetWidth;
            const barHeight = actualBarHeight;
            const barWidth = actualBarWidth;
            const margin = 16; // Increased margin for better collision avoidance
            const gap = 16;
            // Account for scroll position
            const scrollX = window.scrollX;
            const scrollY = window.scrollY;
            // Determine vertical position (above or below)
            const spaceAbove = rect.top;
            const spaceBelow = window.innerHeight - rect.bottom;
            const requiredHeight = barHeight + gap + margin;
            let y;
            if (spaceAbove >= requiredHeight) {
                // Position above the element with gap
                y = rect.top - barHeight - gap + scrollY;
            }
            else if (spaceBelow >= requiredHeight) {
                // Position below the element with gap
                y = rect.bottom + gap + scrollY;
            }
            else {
                // Not enough space either way, prefer above with gap and clamp
                y = clamp(rect.top - barHeight - gap + scrollY, margin + scrollY, window.innerHeight - barHeight - margin + scrollY);
            }
            // Horizontal position - left-align to element and clamp to viewport
            let x = rect.left + scrollX;
            // Simple clamping to ensure within bounds with 16px margin
            x = clamp(x, margin + scrollX, window.innerWidth - barWidth - margin + scrollX);
            y = clamp(y, margin + scrollY, window.innerHeight - barHeight - margin + scrollY);
            setPosition({ x, y });
        }
    }, [activeElement, isCustomPosition, barRef.current?.offsetHeight]);
    // Effect to handle input event listener for text changes
    useEffect(() => {
        const handleInput = (e) => {
            const newText = e.target.innerText;
            updateActiveElementStyle({ text: newText });
        };
        if (activeElement) {
            activeElement.addEventListener("input", handleInput);
        }
        return () => {
            if (activeElement) {
                activeElement.removeEventListener("input", handleInput);
            }
        };
    }, [activeElement, updateActiveElementStyle]);
    // Effect to append the bar to the popover container
    useEffect(() => {
        if (barRef.current && popoverContainer) {
            popoverContainer.appendChild(barRef.current);
        }
        return () => {
            if (barRef.current &&
                popoverContainer &&
                popoverContainer.contains(barRef.current)) {
                popoverContainer.removeChild(barRef.current);
            }
        };
    }, [popoverContainer]);
    // Formatting-related handlers were removed (now live inside TextGroup)
    const handleClick = (e) => {
        // Prevent the click from propagating to the document and re-selecting the element
        e.stopPropagation();
    };
    if (!activeElement) {
        return null;
    }
    return (_jsxs("div", { ref: barRef, className: `${isCustomPosition ? "fixed" : "absolute"} bg-white rounded-lg shadow-2xl p-3 flex flex-col z-[2147483646] min-w-[520px] max-h-[100px]`, style: {
            top: `${position.y}px`,
            left: `${position.x}px`,
            animation: "fadeInPopover 0.15s ease-out forwards",
        }, onClick: handleClick, onMouseDown: (e) => {
            const target = e.target;
            const tag = target.tagName;
            if (["INPUT", "SELECT", "TEXTAREA", "BUTTON"].includes(tag)) {
                return;
            }
            e.preventDefault();
        }, children: [_jsxs(Tabs, { value: currentTab, onValueChange: (v) => setCurrentTab(v), className: "flex flex-col", children: [_jsx(Header, { onClose: onClose, onOpenDesignPanel: onOpenDesignPanel, onOpenAgentChat: () => toggleAgent(true), onDragMouseDown: handleHeaderMouseDown }), _jsx(TabsContent, { value: "image", children: _jsx(ImageGroup, { popoverContainer: popoverContainer }) }), _jsx(TabsContent, { value: "text", children: _jsx(TextGroup, { popoverContainer: popoverContainer, onClose: onClose }) }), _jsx(TabsContent, { value: "container", children: _jsx(ContainerGroup, { popoverContainer: popoverContainer }) }), _jsx(TabsContent, { value: "layout", children: _jsx(LayoutGroup, {}) }), _jsx(TabsContent, { value: "statesMotion", children: _jsx(StatesMotionGroup, {}) })] }), isAgentOpen && (_jsx("div", { className: "absolute top-0 left-full ml-3 z-10", children: _jsx(AgentChatOverlay, { onClose: () => toggleAgent(false) }) }))] }));
};
export default DesignBar;
