import { isThenable as f } from "./index132.js";
const u = 0, a = 1, _ = 2;
function E(c) {
  return new h((t) => {
    t(c);
  });
}
function l(c) {
  return new h((t, s) => {
    s(c);
  });
}
class h {
  constructor(t) {
    this._state = u, this._handlers = [], this._runExecutor(t);
  }
  /** @inheritdoc */
  then(t, s) {
    return new h((n, r) => {
      this._handlers.push([
        !1,
        (e) => {
          if (!t)
            n(e);
          else
            try {
              n(t(e));
            } catch (i) {
              r(i);
            }
        },
        (e) => {
          if (!s)
            r(e);
          else
            try {
              n(s(e));
            } catch (i) {
              r(i);
            }
        }
      ]), this._executeHandlers();
    });
  }
  /** @inheritdoc */
  catch(t) {
    return this.then((s) => s, t);
  }
  /** @inheritdoc */
  finally(t) {
    return new h((s, n) => {
      let r, e;
      return this.then(
        (i) => {
          e = !1, r = i, t && t();
        },
        (i) => {
          e = !0, r = i, t && t();
        }
      ).then(() => {
        if (e) {
          n(r);
          return;
        }
        s(r);
      });
    });
  }
  /** Excute the resolve/reject handlers. */
  _executeHandlers() {
    if (this._state === u)
      return;
    const t = this._handlers.slice();
    this._handlers = [], t.forEach((s) => {
      s[0] || (this._state === a && s[1](this._value), this._state === _ && s[2](this._value), s[0] = !0);
    });
  }
  /** Run the executor for the SyncPromise. */
  _runExecutor(t) {
    const s = (e, i) => {
      if (this._state === u) {
        if (f(i)) {
          i.then(n, r);
          return;
        }
        this._state = e, this._value = i, this._executeHandlers();
      }
    }, n = (e) => {
      s(a, e);
    }, r = (e) => {
      s(_, e);
    };
    try {
      t(n, r);
    } catch (e) {
      r(e);
    }
  }
}
export {
  h as SyncPromise,
  l as rejectedSyncPromise,
  E as resolvedSyncPromise
};
